let e;function t(t){let r,s;if("undefined"!=typeof TextDecoder)try{r=new TextDecoder("utf-8"),s=new TextDecoder("windows-1252")}catch(e){console.warn("TextDecoder not supported - pc.Untar module will not work")}else console.warn("TextDecoder not supported - pc.Untar module will not work");function a(e){this._fields=e}function n(e){this._arrayBuffer=e||new ArrayBuffer(0),this._bufferView=new DataView(this._arrayBuffer),this._globalPaxHeader=null,this._paxHeader=null,this._bytesRead=0}a.parse=function(e,t,s){const n=new Uint8Array(e,t,s);let i=0;const o=[];for(;i<s;){let a;for(a=i;a<s&&32!==n[a];a++);if(a>=s)throw new Error("Invalid PAX header data format.");const l=parseInt(r.decode(new Uint8Array(e,t+i,a-i)),10),d=r.decode(new Uint8Array(e,t+a+1,l-(a-i)-2)).split("=");if(2!==d.length)throw new Error("Invalid PAX header data format.");0===d[1].length&&(d[1]=null),o.push({name:d[0],value:d[1]}),i+=l}return new a(o)},a.prototype.applyHeader=function(e){for(let t=0;t<this._fields.length;t++){let r=this._fields[t].name;const s=this._fields[t].value;"path"===r&&(r="name"),null===s?delete e[r]:e[r]=s}},t||(e=n),n.prototype._hasNext=function(){return this._bytesRead+4<this._arrayBuffer.byteLength&&0!==this._bufferView.getUint32(this._bytesRead)},n.prototype._readNextFile=function(){const e=new DataView(this._arrayBuffer,this._bytesRead,512),r=s.decode(e);this._bytesRead+=512;let n=r.substring(0,100).replace(/\0/g,"");const i=r.substring(257,263),o=parseInt(r.substring(124,136),8),l=r.substring(156,157),d=this._bytesRead;let f=null,u=!1;switch(l){case"0":case"":if(u=!0,!t){const e=new Blob([this._arrayBuffer.slice(this._bytesRead,this._bytesRead+o)]);f=URL.createObjectURL(e)}break;case"g":this._globalPaxHeader=a.parse(this._arrayBuffer,this._bytesRead,o);break;case"x":this._paxHeader=a.parse(this._arrayBuffer,this._bytesRead,o)}this._bytesRead+=o;const h=o%512;if(0!==h&&(this._bytesRead+=512-h),!u)return null;if(-1!==i.indexOf("ustar")){const e=r.substring(345,500).replace(/\0/g,"");e.length>0&&(n=e.trim()+n.trim())}const c={name:n,start:d,size:o,url:f};return this._globalPaxHeader&&this._globalPaxHeader.applyHeader(c),this._paxHeader&&(this._paxHeader.applyHeader(c),this._paxHeader=null),c},n.prototype.untar=function(e){if(!r)return console.error("Cannot untar because TextDecoder interface is not available for this platform."),[];const t=[];for(;this._hasNext();){const r=this._readNextFile();r&&(e&&r.name&&(r.name=e+r.name),t.push(r))}return t},t&&(self.onmessage=function(e){const t=e.data.id;try{const r=new n(e.data.arrayBuffer).untar(e.data.prefix);postMessage({id:t,files:r,arrayBuffer:e.data.arrayBuffer},[e.data.arrayBuffer])}catch(e){postMessage({id:t,error:e.toString()})}})}let r=null;class s{constructor(e){this._requestId=0,this._pendingRequests={},this._filenamePrefix=e,this._worker=new Worker(function(){if(!r){const e="("+t.toString()+")(true)\n\n",s=new Blob([e],{type:"application/javascript"});r=URL.createObjectURL(s)}return r}()),this._worker.addEventListener("message",this._onMessage.bind(this))}_onMessage(e){const t=e.data.id;if(!this._pendingRequests[t])return;const r=this._pendingRequests[t];if(delete this._pendingRequests[t],e.data.error)r(e.data.error);else{const t=e.data.arrayBuffer;for(let r=0,s=e.data.files.length;r<s;r++){const s=e.data.files[r],a=new Blob([t.slice(s.start,s.start+s.size)]);s.url=URL.createObjectURL(a)}r(null,e.data.files)}}untar(e,t){const r=this._requestId++;this._pendingRequests[r]=t,this._worker.postMessage({id:r,prefix:this._filenamePrefix,arrayBuffer:e},[e])}hasPendingRequests(){return Object.keys(this._pendingRequests).length>0}destroy(){this._worker&&(this._worker.terminate(),this._worker=null,this._pendingRequests=null)}}t();export{e as Untar,s as UntarWorker};

import{math as t}from"../../../core/math/math.js";import{INTERPOLATION_STEP as i,INTERPOLATION_CUBIC as s,INTERPOLATION_LINEAR as h}from"../constants.js";class e{constructor(){this._left=1/0,this._right=-1/0,this._len=0,this._recip=0,this._p0=0,this._p1=0,this._t=0,this._hermite={valid:!1,p0:0,m0:0,p1:0,m1:0}}update(t,i){if(t<this._left||t>=this._right){const s=i.length;if(s)if(t<i[0])this._left=-1/0,this._right=i[0],this._len=0,this._recip=0,this._p0=this._p1=0;else if(t>=i[s-1])this._left=i[s-1],this._right=1/0,this._len=0,this._recip=0,this._p0=this._p1=s-1;else{const s=this._findKey(t,i);this._left=i[s],this._right=i[s+1],this._len=this._right-this._left;const h=1/this._len;this._recip=isFinite(h)?h:0,this._p0=s,this._p1=s+1}else this._left=-1/0,this._right=1/0,this._len=0,this._recip=0,this._p0=this._p1=0}this._t=0===this._recip?0:(t-this._left)*this._recip,this._hermite.valid=!1}_findKey(t,i){let s=0;for(;t>=i[s+1];)s++;return s}eval(e,_,p){const r=p._data,l=p._components,n=this._p0*l;if(_===i)for(let t=0;t<l;++t)e[t]=r[n+t];else{const i=this._t,p=this._p1*l;switch(_){case h:for(let s=0;s<l;++s)e[s]=t.lerp(r[n+s],r[p+s],i);break;case s:{const t=this._hermite;if(!t.valid){const s=i*i,h=i+i,e=1-i,_=e*e;t.valid=!0,t.p0=(1+h)*_,t.m0=i*_,t.p1=s*(3-h),t.m1=s*(i-1)}const s=(3*this._p0+1)*l,h=(3*this._p0+2)*l,_=(3*this._p1+1)*l,p=(3*this._p1+0)*l;for(let i=0;i<l;++i)e[i]=t.p0*r[s+i]+t.m0*r[h+i]*this._len+t.p1*r[_+i]+t.m1*r[p+i]*this._len;break}}}}}export{e as AnimCache};

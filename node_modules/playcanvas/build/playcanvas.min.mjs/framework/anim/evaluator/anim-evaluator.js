import{AnimTargetValue as t}from"./anim-target-value.js";import{AnimBlend as e}from"./anim-blend.js";class s{constructor(t){this._binder=t,this._clips=[],this._inputs=[],this._outputs=[],this._targets={}}get clips(){return this._clips}addClip(e){const s=this._targets,n=this._binder,r=e.track.curves,a=e.snapshot,i=[],o=[];for(let e=0;e<r.length;++e){const l=r[e].paths;for(let r=0;r<l.length;++r){const h=l[r],u=n.resolve(h);let p=s[u&&u.targetPath||null];if(!p&&u){p={target:u,value:[],curves:0,blendCounter:0};for(let t=0;t<p.target.components;++t)p.value.push(0);if(s[u.targetPath]=p,n.animComponent){if(!n.animComponent.targets[u.targetPath]){let e;e="localRotation"===u.targetPath.substring(u.targetPath.length-13)?t.TYPE_QUAT:t.TYPE_VEC3,n.animComponent.targets[u.targetPath]=new t(n.animComponent,e)}n.animComponent.targets[u.targetPath].layerCounter++,n.animComponent.targets[u.targetPath].setMask(n.layerIndex,1)}}p&&(p.curves++,i.push(a._results[e]),o.push(p))}}this._clips.push(e),this._inputs.push(i),this._outputs.push(o)}removeClip(t){const e=this._targets,s=this._binder,n=this._clips,r=n[t].track.curves;for(let t=0;t<r.length;++t){const n=r[t].paths;for(let t=0;t<n.length;++t){const r=n[t],a=this._binder.resolve(r);a&&(a.curves--,0===a.curves&&(s.unresolve(r),delete e[a.targetPath],s.animComponent&&s.animComponent.targets[a.targetPath].layerCounter--))}}n.splice(t,1),this._inputs.splice(t,1),this._outputs.splice(t,1)}removeClips(){for(;this._clips.length>0;)this.removeClip(0)}findClip(t){const e=this._clips;for(let s=0;s<e.length;++s){const n=e[s];if(n.name===t)return n}return null}rebind(){this._binder.rebind(),this._targets={};const t=[...this.clips];this.removeClips(),t.forEach((t=>{this.addClip(t)}))}assignMask(t){return this._binder.assignMask(t)}update(t){const s=this._clips,n=s.map((function(t,e){return e}));e.stableSort(n,(function(t,e){return s[t].blendOrder<s[e].blendOrder}));for(let r=0;r<n.length;++r){const a=n[r],i=s[a],o=this._inputs[a],l=this._outputs[a],h=i.blendWeight;let u,p,g;if(h>0&&i._update(t),h>=1)for(let t=0;t<o.length;++t)u=o[t],p=l[t],g=p.value,e.set(g,u,p.target.type),p.blendCounter++;else if(h>0)for(let t=0;t<o.length;++t)u=o[t],p=l[t],g=p.value,0===p.blendCounter?e.set(g,u,p.target.type):e.blend(g,u,h,p.target.type),p.blendCounter++}const r=this._targets,a=this._binder;for(const t in r)if(r.hasOwnProperty(t)){const e=r[t];if(a.animComponent&&e.target.isTransform){const s=a.animComponent.targets[t];s.counter===s.layerCounter&&(s.counter=0),s.path||(s.path=t,s.baseValue=e.target.get(),s.setter=e.target.set),s.updateValue(a.layerIndex,e.value),s.counter++}else e.target.set(e.value);e.blendCounter=0}a.update(t)}}export{s as AnimEvaluator};

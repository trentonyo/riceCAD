import{Vec2 as t}from"../../../core/math/vec2.js";import{math as e}from"../../../core/math/math.js";import{AnimBlendTree as i}from"./anim-blend-tree.js";class n extends i{pointCache(e,i){const n=`${e}${i}`;return this._pointCache[n]||(this._pointCache[n]=new t((this._children[i].pointLength-this._children[e].pointLength)/((this._children[i].pointLength+this._children[e].pointLength)/2),2*t.angleRad(this._children[e].point,this._children[i].point))),this._pointCache[n]}calculateWeights(){if(this.updateParameterValues())return;let i,h;n._p.set(...this._parameterValues);const s=n._p.length();i=0,h=0;for(let o=0;o<this._children.length;o++){const r=this._children[o],a=r.point,c=r.pointLength;let p=Number.MAX_VALUE;for(let i=0;i<this._children.length;i++){if(o===i)continue;const h=this.pointCache(o,i),r=this._children[i].pointLength;n._pip.set((s-c)/((r+c)/2),2*t.angleRad(a,n._p));const l=e.clamp(1-Math.abs(n._pip.dot(h)/h.lengthSq()),0,1);l<p&&(p=l)}r.weight=p,i+=p,this._syncAnimations&&(h+=r.animTrack.duration/r.absoluteSpeed*r.weight)}for(let t=0;t<this._children.length;t++){const e=this._children[t];if(e.weight=e._weight/i,this._syncAnimations){const t=e.animTrack.duration/h*i;e.weightedSpeed=e.absoluteSpeed*t}}}}n._p=new t,n._pip=new t;export{n as AnimBlendTreeDirectional2D};

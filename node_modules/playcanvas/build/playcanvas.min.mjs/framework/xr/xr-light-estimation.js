import{EventHandler as t}from"../../core/event-handler.js";import{Color as e}from"../../core/math/color.js";import{Mat4 as i}from"../../core/math/mat4.js";import{Quat as s}from"../../core/math/quat.js";import{Vec3 as r}from"../../core/math/vec3.js";import{XRTYPE_AR as o}from"./constants.js";const a=new r,n=new r,h=new i,l=new i;class _ extends t{constructor(t){super(),this._manager=void 0,this._supported=!1,this._available=!1,this._lightProbeRequested=!1,this._lightProbe=null,this._intensity=0,this._rotation=new s,this._color=new e,this._sphericalHarmonics=new Float32Array(27),this._manager=t,this._manager.on("start",this._onSessionStart,this),this._manager.on("end",this._onSessionEnd,this)}_onSessionStart(){!!this._manager.session.requestLightProbe&&(this._supported=!0)}_onSessionEnd(){this._supported=!1,this._available=!1,this._lightProbeRequested=!1,this._lightProbe=null}start(){let t;this._manager.session||(t=new Error("XR session is not running")),t||this._manager.type===o||(t=new Error("XR session type is not AR")),t||this._supported||(t=new Error("light-estimation is not supported")),(!t&&this._lightProbe||this._lightProbeRequested)&&(t=new Error("light estimation is already requested")),t?this.fire("error",t):(this._lightProbeRequested=!0,this._manager.session.requestLightProbe().then((t=>{const e=this._lightProbeRequested;this._lightProbeRequested=!1,this._manager.active?e&&(this._lightProbe=t):this.fire("error",new Error("XR session is not active"))})).catch((t=>{this._lightProbeRequested=!1,this.fire("error",t)})))}end(){this._lightProbeRequested=!1,this._lightProbe=null,this._available=!1}update(t){if(!this._lightProbe)return;const e=t.getLightEstimate(this._lightProbe);if(!e)return;this._available||(this._available=!0,this.fire("available"));const i=e.primaryLightIntensity;this._intensity=Math.max(1,Math.max(i.x,Math.max(i.y,i.z))),a.copy(i).mulScalar(1/this._intensity),this._color.set(a.x,a.y,a.z),a.set(0,0,0),n.copy(e.primaryLightDirection),h.setLookAt(n,a,r.UP),l.setFromAxisAngle(r.RIGHT,90),h.mul(l),this._rotation.setFromMat4(h),this._sphericalHarmonics.set(e.sphericalHarmonicsCoefficients)}get supported(){return this._supported}get available(){return this._available}get intensity(){return this._available?this._intensity:null}get color(){return this._available?this._color:null}get rotation(){return this._available?this._rotation:null}get sphericalHarmonics(){return this._available?this._sphericalHarmonics:null}}export{_ as XrLightEstimation};

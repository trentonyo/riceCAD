import{platform as s}from"../../core/platform.js";import{EventHandler as e}from"../../core/event-handler.js";import{XRTYPE_AR as t,XRSPACE_VIEWER as i}from"./constants.js";import{XrHitTestSource as r}from"./xr-hit-test-source.js";class o extends e{constructor(e){super(),this.manager=void 0,this._supported=s.browser&&!(!window.XRSession||!window.XRSession.prototype.requestHitTestSource),this._session=null,this.sources=[],this.manager=e,this._supported&&(this.manager.on("start",this._onSessionStart,this),this.manager.on("end",this._onSessionEnd,this))}_onSessionStart(){this.manager.type===t&&(this._session=this.manager.session)}_onSessionEnd(){if(this._session){this._session=null;for(let s=0;s<this.sources.length;s++)this.sources[s].onStop();this.sources=[]}}isAvailable(s,e){let i;return this._supported||(i=new Error("XR HitTest is not supported")),this._session||(i=new Error("XR Session is not started (1)")),this.manager.type!==t&&(i=new Error("XR HitTest is available only for AR")),!i||(s&&s(i),e&&e.fire("error",i),!1)}start(s={}){if(!this.isAvailable(s.callback,this))return;let e;s.profile||s.spaceType||(s.spaceType=i);const t=s.offsetRay;if(t){const s=new DOMPoint(t.origin.x,t.origin.y,t.origin.z,1),i=new DOMPoint(t.direction.x,t.direction.y,t.direction.z,0);e=new XRRay(s,i)}const r=s.callback;s.spaceType?this._session.requestReferenceSpace(s.spaceType).then((t=>{if(!this._session){const s=new Error("XR Session is not started (2)");return r&&r(s),void this.fire("error",s)}this._session.requestHitTestSource({space:t,entityTypes:s.entityTypes||void 0,offsetRay:e}).then((s=>{this._onHitTestSource(s,!1,r)})).catch((s=>{r&&r(s),this.fire("error",s)}))})).catch((s=>{r&&r(s),this.fire("error",s)})):this._session.requestHitTestSourceForTransientInput({profile:s.profile,entityTypes:s.entityTypes||void 0,offsetRay:e}).then((s=>{this._onHitTestSource(s,!0,r)})).catch((s=>{r&&r(s),this.fire("error",s)}))}_onHitTestSource(s,e,t){if(!this._session){s.cancel();const e=new Error("XR Session is not started (3)");return t&&t(e),void this.fire("error",e)}const i=new r(this.manager,s,e);this.sources.push(i),t&&t(null,i),this.fire("add",i)}update(s){for(let e=0;e<this.sources.length;e++)this.sources[e].update(s)}get supported(){return this._supported}}export{o as XrHitTest};

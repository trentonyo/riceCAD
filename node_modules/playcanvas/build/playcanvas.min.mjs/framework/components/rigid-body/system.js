import"../../../core/time.js";import{ObjectPool as t}from"../../../core/object-pool.js";import"../../../core/tracing.js";import{Vec3 as o}from"../../../core/math/vec3.js";import{Component as i}from"../component.js";import{ComponentSystem as s}from"../system.js";import{BODYFLAG_NORESPONSE_OBJECT as e}from"./constants.js";import{RigidBodyComponent as n}from"./component.js";import{RigidBodyComponentData as l}from"./data.js";let r,a;class c{constructor(t,o,i){this.entity=t,this.point=o,this.normal=i}}class h{constructor(t,i,s){0===arguments.length?(this.a=null,this.b=null,this.impulse=0,this.localPointA=new o,this.localPointB=new o,this.pointA=new o,this.pointB=new o,this.normal=new o):(this.a=t,this.b=i,this.impulse=s.impulse,this.localPointA=s.localPoint,this.localPointB=s.localPointOther,this.pointA=s.point,this.pointB=s.pointOther,this.normal=s.normal)}}class m{constructor(t=new o,i=new o,s=new o,e=new o,n=new o,l=0){this.localPoint=t,this.localPointOther=i,this.point=s,this.pointOther=e,this.normal=n,this.impulse=l}}class d{constructor(t,o){this.other=t,this.contacts=o}}const g=["enabled"];class y extends s{constructor(t){super(t),this.maxSubSteps=10,this.fixedTimeStep=1/60,this.gravity=new o(0,-9.81,0),this._dynamic=[],this._kinematic=[],this._triggers=[],this._compounds=[],this.id="rigidbody",this._stats=t.stats.frame,this.ComponentType=n,this.DataType=l,this.contactPointPool=null,this.contactResultPool=null,this.singleContactResultPool=null,this.schema=g,this.collisions={},this.frameCollisions={},this.on("beforeremove",this.onBeforeRemove,this),this.on("remove",this.onRemove,this)}onLibraryLoaded(){if("undefined"!=typeof Ammo){if(this.collisionConfiguration=new Ammo.btDefaultCollisionConfiguration,this.dispatcher=new Ammo.btCollisionDispatcher(this.collisionConfiguration),this.overlappingPairCache=new Ammo.btDbvtBroadphase,this.solver=new Ammo.btSequentialImpulseConstraintSolver,this.dynamicsWorld=new Ammo.btDiscreteDynamicsWorld(this.dispatcher,this.overlappingPairCache,this.solver,this.collisionConfiguration),this.dynamicsWorld.setInternalTickCallback){const t=Ammo.addFunction(this._checkForCollisions.bind(this),"vif");this.dynamicsWorld.setInternalTickCallback(t)}r=new Ammo.btVector3,a=new Ammo.btVector3,n.onLibraryLoaded(),this.contactPointPool=new t(m,1),this.contactResultPool=new t(d,1),this.singleContactResultPool=new t(h,1),this.app.systems.on("update",this.onUpdate,this)}else this.app.systems.off("update",this.onUpdate,this)}initializeComponentData(t,i,s){const e=["mass","linearDamping","angularDamping","linearFactor","angularFactor","friction","rollingFriction","restitution","type","group","mask"];for(const s of e)if(i.hasOwnProperty(s)){const e=i[s];Array.isArray(e)?t[s]=new o(e[0],e[1],e[2]):t[s]=e}super.initializeComponentData(t,i,["enabled"])}cloneComponent(t,o){const i=t.rigidbody,s={enabled:i.enabled,mass:i.mass,linearDamping:i.linearDamping,angularDamping:i.angularDamping,linearFactor:[i.linearFactor.x,i.linearFactor.y,i.linearFactor.z],angularFactor:[i.angularFactor.x,i.angularFactor.y,i.angularFactor.z],friction:i.friction,rollingFriction:i.rollingFriction,restitution:i.restitution,type:i.type,group:i.group,mask:i.mask};return this.addComponent(o,s)}onBeforeRemove(t,o){o.enabled&&(o.enabled=!1)}onRemove(t,o){const i=o.body;i&&(this.removeBody(i),this.destroyBody(i),o.body=null)}addBody(t,o,i){void 0!==o&&void 0!==i?this.dynamicsWorld.addRigidBody(t,o,i):this.dynamicsWorld.addRigidBody(t)}removeBody(t){this.dynamicsWorld.removeRigidBody(t)}createBody(t,o,i){const s=new Ammo.btVector3(0,0,0);0!==t&&o.calculateLocalInertia(t,s);const e=new Ammo.btDefaultMotionState(i),n=new Ammo.btRigidBodyConstructionInfo(t,e,o,s),l=new Ammo.btRigidBody(n);return Ammo.destroy(n),Ammo.destroy(s),l}destroyBody(t){const o=t.getMotionState();o&&Ammo.destroy(o),Ammo.destroy(t)}raycastFirst(t,i){let s=null;r.setValue(t.x,t.y,t.z),a.setValue(i.x,i.y,i.z);const e=new Ammo.ClosestRayResultCallback(r,a);if(this.dynamicsWorld.rayTest(r,a,e),e.hasHit()){const t=e.get_m_collisionObject(),i=Ammo.castObject(t,Ammo.btRigidBody);if(i){const t=e.get_m_hitPointWorld(),n=e.get_m_hitNormalWorld();if(s=new c(i.entity,new o(t.x(),t.y(),t.z()),new o(n.x(),n.y(),n.z())),arguments.length>2){(0,arguments[2])(s)}}}return Ammo.destroy(e),s}raycastAll(t,i){const s=[];r.setValue(t.x,t.y,t.z),a.setValue(i.x,i.y,i.z);const e=new Ammo.AllHitsRayResultCallback(r,a);if(this.dynamicsWorld.rayTest(r,a,e),e.hasHit()){const t=e.get_m_collisionObjects(),i=e.get_m_hitPointWorld(),n=e.get_m_hitNormalWorld(),l=t.size();for(let e=0;e<l;e++){const l=Ammo.castObject(t.at(e),Ammo.btRigidBody);if(l){const t=i.at(e),r=n.at(e),a=new c(l.entity,new o(t.x(),t.y(),t.z()),new o(r.x(),r.y(),r.z()));s.push(a)}}}return Ammo.destroy(e),s}_storeCollision(t,o){let i=!1;const s=t.getGuid();return this.collisions[s]=this.collisions[s]||{others:[],entity:t},this.collisions[s].others.indexOf(o)<0&&(this.collisions[s].others.push(o),i=!0),this.frameCollisions[s]=this.frameCollisions[s]||{others:[],entity:t},this.frameCollisions[s].others.push(o),i}_createContactPointFromAmmo(t){const o=t.get_m_localPointA(),i=t.get_m_localPointB(),s=t.getPositionWorldOnA(),e=t.getPositionWorldOnB(),n=t.get_m_normalWorldOnB(),l=this.contactPointPool.allocate();return l.localPoint.set(o.x(),o.y(),o.z()),l.localPointOther.set(i.x(),i.y(),i.z()),l.point.set(s.x(),s.y(),s.z()),l.pointOther.set(e.x(),e.y(),e.z()),l.normal.set(n.x(),n.y(),n.z()),l.impulse=t.getAppliedImpulse(),l}_createReverseContactPointFromAmmo(t){const o=t.get_m_localPointA(),i=t.get_m_localPointB(),s=t.getPositionWorldOnA(),e=t.getPositionWorldOnB(),n=t.get_m_normalWorldOnB(),l=this.contactPointPool.allocate();return l.localPointOther.set(o.x(),o.y(),o.z()),l.localPoint.set(i.x(),i.y(),i.z()),l.pointOther.set(s.x(),s.y(),s.z()),l.point.set(e.x(),e.y(),e.z()),l.normal.set(n.x(),n.y(),n.z()),l.impulse=t.getAppliedImpulse(),l}_createSingleContactResult(t,o,i){const s=this.singleContactResultPool.allocate();return s.a=t,s.b=o,s.localPointA=i.localPoint,s.localPointB=i.localPointOther,s.pointA=i.point,s.pointB=i.pointOther,s.normal=i.normal,s.impulse=i.impulse,s}_createContactResult(t,o){const i=this.contactResultPool.allocate();return i.other=t,i.contacts=o,i}_cleanOldCollisions(){for(const t in this.collisions)if(this.collisions.hasOwnProperty(t)){const o=this.frameCollisions[t],i=this.collisions[t],s=i.entity,e=s.collision,n=s.rigidbody,l=i.others;let r=l.length;for(;r--;){const t=l[r];(!o||o.others.indexOf(t)<0)&&(l.splice(r,1),s.trigger?(e&&e.fire("triggerleave",t),t.rigidbody&&t.rigidbody.fire("triggerleave",s)):t.trigger||(n&&n.fire("collisionend",t),e&&e.fire("collisionend",t)))}0===l.length&&delete this.collisions[t]}}_hasContactEvent(t){const o=t.collision;if(o&&(o.hasEvent("collisionstart")||o.hasEvent("collisionend")||o.hasEvent("contact")))return!0;const i=t.rigidbody;return i&&(i.hasEvent("collisionstart")||i.hasEvent("collisionend")||i.hasEvent("contact"))}_checkForCollisions(t,o){const i=Ammo.wrapPointer(t,Ammo.btDynamicsWorld).getDispatcher(),s=i.getNumManifolds();this.frameCollisions={};for(let t=0;t<s;t++){const o=i.getManifoldByIndexInternal(t),s=o.getBody0(),n=o.getBody1(),l=Ammo.castObject(s,Ammo.btRigidBody),r=Ammo.castObject(n,Ammo.btRigidBody),a=l.entity,c=r.entity;if(!a||!c)continue;const h=l.getCollisionFlags(),m=r.getCollisionFlags(),d=o.getNumContacts(),g=[],y=[];let p;if(d>0)if(h&e||m&e){const t=a.collision&&(a.collision.hasEvent("triggerenter")||a.collision.hasEvent("triggerleave")),o=c.collision&&(c.collision.hasEvent("triggerenter")||c.collision.hasEvent("triggerleave")),i=a.rigidbody&&(a.rigidbody.hasEvent("triggerenter")||a.rigidbody.hasEvent("triggerleave")),s=c.rigidbody&&(c.rigidbody.hasEvent("triggerenter")||c.rigidbody.hasEvent("triggerleave"));t&&(p=this._storeCollision(a,c),!p||m&e||a.collision.fire("triggerenter",c)),o&&(p=this._storeCollision(c,a),!p||h&e||c.collision.fire("triggerenter",a)),i&&(p||(p=this._storeCollision(c,a)),p&&a.rigidbody.fire("triggerenter",c)),s&&(p||(p=this._storeCollision(a,c)),p&&c.rigidbody.fire("triggerenter",a))}else{const t=this._hasContactEvent(a),i=this._hasContactEvent(c),s=this.hasEvent("contact");if(s||t||i){for(let e=0;e<d;e++){const n=o.getContactPoint(e),l=this._createContactPointFromAmmo(n);if(t||i){g.push(l);const t=this._createReverseContactPointFromAmmo(n);y.push(t)}if(s){const t=this._createSingleContactResult(a,c,l);this.fire("contact",t)}}if(t){const t=this._createContactResult(c,g);p=this._storeCollision(a,c),a.collision&&(a.collision.fire("contact",t),p&&a.collision.fire("collisionstart",t)),a.rigidbody&&(a.rigidbody.fire("contact",t),p&&a.rigidbody.fire("collisionstart",t))}if(i){const t=this._createContactResult(a,y);p=this._storeCollision(c,a),c.collision&&(c.collision.fire("contact",t),p&&c.collision.fire("collisionstart",t)),c.rigidbody&&(c.rigidbody.fire("contact",t),p&&c.rigidbody.fire("collisionstart",t))}}}}this._cleanOldCollisions(),this.contactPointPool.freeAll(),this.contactResultPool.freeAll(),this.singleContactResultPool.freeAll()}onUpdate(t){let o,i;const s=this.dynamicsWorld.getGravity();s.x()===this.gravity.x&&s.y()===this.gravity.y&&s.z()===this.gravity.z||(s.setValue(this.gravity.x,this.gravity.y,this.gravity.z),this.dynamicsWorld.setGravity(s));const e=this._triggers;for(o=0,i=e.length;o<i;o++)e[o].updateTransform();const n=this._compounds;for(o=0,i=n.length;o<i;o++)n[o]._updateCompound();const l=this._kinematic;for(o=0,i=l.length;o<i;o++)l[o]._updateKinematic();this.dynamicsWorld.stepSimulation(t,this.maxSubSteps,this.fixedTimeStep);const r=this._dynamic;for(o=0,i=r.length;o<i;o++)r[o]._updateDynamic();this.dynamicsWorld.setInternalTickCallback||this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld),t)}destroy(){super.destroy(),this.app.systems.off("update",this.onUpdate,this),"undefined"!=typeof Ammo&&(Ammo.destroy(this.dynamicsWorld),Ammo.destroy(this.solver),Ammo.destroy(this.overlappingPairCache),Ammo.destroy(this.dispatcher),Ammo.destroy(this.collisionConfiguration),this.dynamicsWorld=null,this.solver=null,this.overlappingPairCache=null,this.dispatcher=null,this.collisionConfiguration=null)}}i._buildAccessors(n.prototype,g);export{m as ContactPoint,d as ContactResult,c as RaycastResult,y as RigidBodyComponentSystem,h as SingleContactResult};

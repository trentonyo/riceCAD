import{AnimTarget as t}from"../../anim/evaluator/anim-target.js";import{DefaultAnimBinder as e}from"../../anim/binder/default-anim-binder.js";import{AnimBinder as r}from"../../anim/binder/anim-binder.js";import{Color as n}from"../../../core/math/color.js";import{Quat as o}from"../../../core/math/quat.js";import{Vec2 as i}from"../../../core/math/vec2.js";import{Vec3 as a}from"../../../core/math/vec3.js";import{Vec4 as s}from"../../../core/math/vec4.js";const c=new i,h=new a,p=new s,l=new n,m=new o;class u extends e{constructor(t,e,r,n,o){super(e),this.animComponent=t,this._mask=n,this.layerName=r,this.layerIndex=o}static _packFloat(t){return t[0]}static _packBoolean(t){return!!t[0]}static _packVec2(t){return c.x=t[0],c.y=t[1],c}static _packVec3(t){return h.x=t[0],h.y=t[1],h.z=t[2],h}static _packVec4(t){return p.x=t[0],p.y=t[1],p.z=t[2],p.w=t[3],p}static _packColor(t){return l.r=t[0],l.g=t[1],l.b=t[2],l.a=t[3],l}static _packQuat(t){return m.x=t[0],m.y=t[1],m.z=t[2],m.w=t[3],m}resolve(t){const e=r.encode(t.entityPath,t.component,t.propertyPath);let n,o,i,a=this.targetCache[e];if(a)return a;switch(t.component){case"entity":n=this._getEntityFromHierarchy(t.entityPath),i=r.encode(n.path,"entity",t.propertyPath),o=n;break;case"graph":if(o=this.findNode(t),!o)return null;i=r.encode(o.path,"graph",t.propertyPath);break;default:if(n=this._getEntityFromHierarchy(t.entityPath),o=n.findComponent(t.component),!o)return null;i=r.encode(n.path,t.component,t.propertyPath)}return a=this._createAnimTargetForProperty(o,t.propertyPath,i),this.targetCache[e]=a,a}update(t){const e=this.activeNodes;if(e)for(let t=0;t<e.length;t++)e[t]._dirtifyLocal()}_getEntityFromHierarchy(t){if(!this.animComponent.entity.name===t[0])return null;const e=this.animComponent.entity;return 1===t.length?e:e._parent.findByPath(t)}_resolvePath(t,e,r){const n=e.length-(r?0:1);for(let r=0;r<n;r++)t=t[e[r]];return t}_setter(t,e,r){const c=this._resolvePath(t,e),h=e[e.length-1],p="set"+h.substring(0,1).toUpperCase()+h.substring(1);if(c[p]){let t=c["get"+h.substring(0,1).toUpperCase()+h.substring(1)].bind(c)();t=[t.x,t.y,t.z,t.w];const e=c[p].bind(c);return{set:t=>{e(r(t))},get:()=>t}}const l=c[h];if("object"==typeof l&&l.hasOwnProperty("copy"))return function(t){l.copy(r(t))};if(-1!==[i,a,s,n,o].indexOf(c.constructor)&&e.length>1){const n=e.length>2?this._resolvePath(t,e.slice(0,-1)):t,o=e[e.length-2];return function(t){c[h]=r(t),n[o]=c}}return function(t){c[h]=r(t)}}_createAnimTargetForProperty(e,r,c){if(this.handlers&&r[0].startsWith("weight."))return this.handlers.weight(e,r[0].replace("weight.",""));if(this.handlers&&"material"===r[0]&&2===r.length){const t=r[1];if(t.endsWith("Map"))return this.handlers.materialTexture(e,t)}const h=this._resolvePath(e,r,!0);if(void 0===h)return null;let p,l,m;if("number"==typeof h)p=this._setter(e,r,u._packFloat),l="vector",m=1;else if("boolean"==typeof h)p=this._setter(e,r,u._packBoolean),l="vector",m=1;else if("object"==typeof h)switch(h.constructor){case i:p=this._setter(e,r,u._packVec2),l="vector",m=2;break;case a:p=this._setter(e,r,u._packVec3),l="vector",m=3;break;case s:p=this._setter(e,r,u._packVec4),l="vector",m=4;break;case n:p=this._setter(e,r,u._packColor),l="vector",m=4;break;case o:p=this._setter(e,r,u._packQuat),l="quaternion",m=4;break;default:return null}return-1!==r.indexOf("material")?new t((function(t){p(t),e.material.update()}),l,m,c):new t(p,l,m,c)}rebind(){this.targetCache={},this.animComponent.rootBone?this.graph=this.animComponent.rootBone:this.graph=this.animComponent.entity;const t={};!function e(r){t[r.name]=r;for(let t=0;t<r.children.length;++t)e(r.children[t])}(this.graph),this.nodes=t}}export{u as AnimComponentBinder};

import"../../../core/tracing.js";import"../../../core/time.js";import{ShaderInput as e}from"../shader-input.js";import{semanticToLocation as t}from"../constants.js";const r=["gl_VertexID","gl_InstanceID","gl_DrawID","gl_BaseVertex","gl_BaseInstance"];class i{constructor(e){this.compileDuration=0,this.init(),this.compileAndLink(e.device,e),e.device.shaders.push(e)}destroy(e){this.glProgram&&(e.device.gl.deleteProgram(this.glProgram),this.glProgram=null)}init(){this.uniforms=[],this.samplers=[],this.attributes=[],this.glProgram=null,this.glVertexShader=null,this.glFragmentShader=null}loseContext(){this.init()}restoreContext(e,t){this.compileAndLink(e,t)}compileAndLink(e,r){const i=r.definition,s=this._compileShaderSource(e,i.vshader,!0),o=this._compileShaderSource(e,i.fshader,!1),n=e.gl,a=n.createProgram();n.attachShader(a,s),n.attachShader(a,o);const h=i.attributes;if(e.webgl2&&i.useTransformFeedback){const e=[];for(const t in h)h.hasOwnProperty(t)&&e.push("out_"+t);n.transformFeedbackVaryings(a,e,n.INTERLEAVED_ATTRIBS)}for(const e in h)if(h.hasOwnProperty(e)){const r=h[e],i=t[r];n.bindAttribLocation(a,i,e)}n.linkProgram(a),this.glVertexShader=s,this.glFragmentShader=o,this.glProgram=a}_compileShaderSource(e,t,r){const i=e.gl,s=r?e.vertexShaderCache:e.fragmentShaderCache;let o=s[t];return o||(o=i.createShader(r?i.VERTEX_SHADER:i.FRAGMENT_SHADER),i.shaderSource(o,t),i.compileShader(o),s[t]=o),o}postLink(t,i){const s=t.gl,o=this.glProgram,n=i.definition;if(!this._isCompiled(t,i,this.glVertexShader,n.vshader,"vertex"))return!1;if(!this._isCompiled(t,i,this.glFragmentShader,n.fshader,"fragment"))return!1;if(!s.getProgramParameter(o,s.LINK_STATUS)){const e="Failed to link shader program. Error: "+s.getProgramInfoLog(o);return console.error(e),!1}let a=0;const h=s.getProgramParameter(o,s.ACTIVE_ATTRIBUTES);for(;a<h;){const i=s.getActiveAttrib(o,a++),h=s.getAttribLocation(o,i.name);if(-1!==r.indexOf(i.name))continue;void 0===n.attributes[i.name]&&console.error(`Vertex shader attribute "${i.name}" is not mapped to a semantic in shader definition.`);const c=new e(t,n.attributes[i.name],t.pcUniformType[i.type],h);this.attributes.push(c)}a=0;const c=s.getProgramParameter(o,s.ACTIVE_UNIFORMS);for(;a<c;){const r=s.getActiveUniform(o,a++),i=s.getUniformLocation(o,r.name),n=new e(t,r.name,t.pcUniformType[r.type],i);r.type===s.SAMPLER_2D||r.type===s.SAMPLER_CUBE||t.webgl2&&(r.type===s.SAMPLER_2D_SHADOW||r.type===s.SAMPLER_CUBE_SHADOW||r.type===s.SAMPLER_3D)?this.samplers.push(n):this.uniforms.push(n)}return i.ready=!0,!0}_isCompiled(e,t,r,i,s){const o=e.gl;if(!o.getShaderParameter(r,o.COMPILE_STATUS)){const e=o.getShaderInfoLog(r),[t,n]=this._processError(i,e),a=`Failed to compile ${s} shader:\n\n${e}\n${t}`;return console.error(a),!1}return!0}_processError(e,t){const r={};let i="";if(e){const s=e.split("\n");let o=0,n=s.length;if(t&&t.startsWith("ERROR:")){const e=t.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);e&&(r.message=e[3],r.line=parseInt(e[2],10),o=Math.max(0,r.line-6),n=Math.min(s.length,r.line+5))}for(let e=o;e<n;e++)i+=e+1+":\t"+s[e]+"\n";r.source=e}return[i,r]}}export{i as WebglShader};

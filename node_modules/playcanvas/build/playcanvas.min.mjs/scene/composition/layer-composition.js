import"../../core/tracing.js";import{EventHandler as t}from"../../core/event-handler.js";import{set as s}from"../../core/set-utils.js";import{sortPriority as e}from"../../core/sort.js";import{LIGHTTYPE_DIRECTIONAL as r,LIGHTTYPE_OMNI as i,LIGHTTYPE_SPOT as h,COMPUPDATED_LIGHTS as a,COMPUPDATED_CAMERAS as l,COMPUPDATED_INSTANCES as n,LAYERID_DEPTH as d,COMPUPDATED_BLEND as o}from"../constants.js";import{RenderAction as u}from"./render-action.js";import{WorldClusters as y}from"../lighting/world-clusters.js";import{LightCompositionData as c}from"./light-composition-data.js";const _=new Set,p=[];class g extends t{constructor(t="Untitled"){super(),this.name=t,this.layerList=[],this.subLayerList=[],this.subLayerEnabled=[],this._opaqueOrder={},this._transparentOrder={},this._dirty=!1,this._dirtyBlend=!1,this._dirtyLights=!1,this._dirtyCameras=!1,this._meshInstances=[],this._meshInstancesSet=new Set,this._lights=[],this._lightsMap=new Map,this._lightCompositionData=[],this._splitLights=[[],[],[]],this.cameras=[],this._renderActions=[],this._worldClusters=[],this._emptyWorldClusters=null}destroy(){this._emptyWorldClusters&&(this._emptyWorldClusters.destroy(),this._emptyWorldClusters=null),this._worldClusters.forEach((t=>{t.destroy()})),this._worldClusters=null,this._renderActions.forEach((t=>t.destroy())),this._renderActions=null}getEmptyWorldClusters(t){return this._emptyWorldClusters||(this._emptyWorldClusters=new y(t),this._emptyWorldClusters.name="ClusterEmpty",this._emptyWorldClusters.update([],!1,null)),this._emptyWorldClusters}_splitLightsArray(t){const s=t._lights;t._splitLights[r].length=0,t._splitLights[i].length=0,t._splitLights[h].length=0;for(let e=0;e<s.length;e++){const r=s[e];r.enabled&&t._splitLights[r._type].push(r)}}_update(t,s=!1){const i=this.layerList.length;let h=0;if(!this._dirty||!this._dirtyLights||!this._dirtyCameras)for(let t=0;t<i;t++){const s=this.layerList[t];s._dirty&&(this._dirty=!0),s._dirtyLights&&(this._dirtyLights=!0),s._dirtyCameras&&(this._dirtyCameras=!0)}function d(t,s,e){let r=!1;const i=e.length;for(let h=0;h<i;h++){const i=e[h];if(!s.has(i)){s.add(i),t.push(i);const e=i.material;e&&e._dirtyBlend&&(r=!0,e._dirtyBlend=!1)}}return r}if(this._dirty){h|=n,this._meshInstances.length=0,this._meshInstancesSet.clear();for(let t=0;t<i;t++){const s=this.layerList[t];s.passThrough||(this._dirtyBlend=d(this._meshInstances,this._meshInstancesSet,s.opaqueMeshInstances)||this._dirtyBlend,this._dirtyBlend=d(this._meshInstances,this._meshInstancesSet,s.transparentMeshInstances)||this._dirtyBlend),s._dirty=!1}this._dirty=!1}function u(t,s,e){for(let i=0;i<s.length;){var r;(null==(r=s[i].material)?void 0:r.transparent)===e?(t.push(s[i]),s[i]=s[s.length-1],s.length--):i++}}if(this._dirtyBlend){h|=o;for(let t=0;t<i;t++){const s=this.layerList[t];s.passThrough||(u(s.opaqueMeshInstances,s.transparentMeshInstances,!1),u(s.transparentMeshInstances,s.opaqueMeshInstances,!0))}this._dirtyBlend=!1}if(this._dirtyLights&&(h|=a,this._dirtyLights=!1,this.updateLights()),h&&this.updateShadowCasters(),this._dirtyCameras||h&a){this._dirtyCameras=!1,h|=l,this.cameras.length=0;for(let t=0;t<i;t++){const s=this.layerList[t];s._dirtyCameras=!1;for(let t=0;t<s.cameras.length;t++){const e=s.cameras[t];this.cameras.indexOf(e)<0&&this.cameras.push(e)}}this.cameras.length>1&&e(this.cameras);const t=[];let s=0;for(let e=0;e<this.cameras.length;e++){const h=this.cameras[e];t.length=0;let a=!0;const l=s;let n=null,d=!1;for(let e=0;e<i;e++){const r=this.layerList[e];if(r&&r.cameras.length>0&&h.layers.indexOf(r.id)>=0){t.push(r),d||r.id!==h.disablePostEffectsLayer||(d=!0,n&&(n.triggerPostprocess=!0));const i=r.cameras.indexOf(h);i>=0&&(n=this.addRenderAction(this._renderActions,s,r,e,i,a,d),s++,a=!1)}}l<s&&(this._renderActions[l].collectDirectionalLights(t,this._splitLights[r],this._lights),n.lastCameraUse=!0),!d&&n&&(n.triggerPostprocess=!0),h.renderTarget&&h.postEffectsEnabled&&this.propagateRenderTarget(l-1,h)}for(let t=s;t<this._renderActions.length;t++)this._renderActions[t].destroy();this._renderActions.length=s}return h&(l|a|n)&&s&&this.allocateLightClusters(t),h&(a|a)&&this._logRenderActions(),h}updateShadowCasters(){const t=this._lights.length;for(let s=0;s<t;s++)this._lightCompositionData[s].clearShadowCasters();const s=this.layerList.length;for(let t=0;t<s;t++){const s=this.layerList[t];if(!_.has(s)){_.add(s);const t=s._lights;for(let e=0;e<t.length;e++)if(t[e].castShadows){const r=this._lightsMap.get(t[e]);this._lightCompositionData[r].addShadowCasters(s.shadowCasters)}}}_.clear()}updateLights(){this._lights.length=0,this._lightsMap.clear();const t=this.layerList.length;for(let s=0;s<t;s++){const t=this.layerList[s];if(!_.has(t)){_.add(t);const s=t._lights;for(let t=0;t<s.length;t++){const e=s[t];let r=this._lightsMap.get(e);if(void 0===r){r=this._lights.length,this._lightsMap.set(e,r),this._lights.push(e);let t=this._lightCompositionData[r];t||(t=new c,this._lightCompositionData[r]=t)}}}this._splitLightsArray(t),t._dirtyLights=!1}_.clear(),this._splitLightsArray(this);const s=this._lights.length;this._lightCompositionData.length=s}findCompatibleCluster(t,e,r){for(let i=0;i<e;i++){const e=this._renderActions[i],h=this.layerList[e.layerIndex];if(e.lightClusters!==r){if(t===h)return e.lightClusters;if(e.lightClusters&&s.equals(t._clusteredLightsSet,h._clusteredLightsSet))return e.lightClusters}}return null}allocateLightClusters(t){p.push(...this._worldClusters);const s=this.getEmptyWorldClusters(t);this._worldClusters.length=0;const e=this._renderActions.length;for(let r=0;r<e;r++){const e=this._renderActions[r],i=this.layerList[e.layerIndex];if(i.hasClusteredLights){if((this.subLayerList[e.layerIndex]?i.transparentMeshInstances:i.opaqueMeshInstances).length){let h=this.findCompatibleCluster(i,r,s);h||(p.length&&(h=p.pop()),h||(h=new y(t)),h.name="Cluster-"+this._worldClusters.length,this._worldClusters.push(h)),e.lightClusters=h}}e.lightClusters||(e.lightClusters=s)}p.forEach((t=>{t.destroy()})),p.length=0}addRenderAction(t,s,e,r,i,h,a){let l=t[s];l||(l=t[s]=new u);let n=e.renderTarget;const o=e.cameras[i];o&&o.renderTarget&&e.id!==d&&(n=o.renderTarget);let y=!1;for(let e=s-1;e>=0;e--)if(t[e].camera===o&&t[e].renderTarget===n){y=!0;break}const c=h||!y;let _=!!c&&o.clearColorBuffer,p=!!c&&o.clearDepthBuffer,g=!!c&&o.clearStencilBuffer;return _||(_=e.clearColorBuffer),p||(p=e.clearDepthBuffer),g||(g=e.clearStencilBuffer),a&&o.postEffectsEnabled&&(n=null),l.reset(),l.triggerPostprocess=!1,l.layerIndex=r,l.cameraIndex=i,l.camera=o,l.renderTarget=n,l.clearColor=_,l.clearDepth=p,l.clearStencil=g,l.firstCameraUse=h,l.lastCameraUse=!1,l}propagateRenderTarget(t,s){for(let e=t;e>=0;e--){const t=this._renderActions[e],r=this.layerList[t.layerIndex];if(t.renderTarget&&r.id!==d)break;if(r.id===d)continue;const i=null==t?void 0:t.camera.camera;if(i&&(!s.camera.rect.equals(i.rect)||!s.camera.scissorRect.equals(i.scissorRect)))break;t.renderTarget=s.renderTarget}}_logRenderActions(){}_isLayerAdded(t){return this.layerList.indexOf(t)>=0}_isSublayerAdded(t,s){for(let e=0;e<this.layerList.length;e++)if(this.layerList[e]===t&&this.subLayerList[e]===s)return!0;return!1}push(t){this._isLayerAdded(t)||(this.layerList.push(t),this.layerList.push(t),this._opaqueOrder[t.id]=this.subLayerList.push(!1)-1,this._transparentOrder[t.id]=this.subLayerList.push(!0)-1,this.subLayerEnabled.push(!0),this.subLayerEnabled.push(!0),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("add",t))}insert(t,s){if(this._isLayerAdded(t))return;this.layerList.splice(s,0,t,t),this.subLayerList.splice(s,0,!1,!0);const e=this.layerList.length;this._updateOpaqueOrder(s,e-1),this._updateTransparentOrder(s,e-1),this.subLayerEnabled.splice(s,0,!0,!0),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("add",t)}remove(t){let s=this.layerList.indexOf(t);for(delete this._opaqueOrder[s],delete this._transparentOrder[s];s>=0;)this.layerList.splice(s,1),this.subLayerList.splice(s,1),this.subLayerEnabled.splice(s,1),s=this.layerList.indexOf(t),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("remove",t);const e=this.layerList.length;this._updateOpaqueOrder(0,e-1),this._updateTransparentOrder(0,e-1)}pushOpaque(t){this._isSublayerAdded(t,!1)||(this.layerList.push(t),this._opaqueOrder[t.id]=this.subLayerList.push(!1)-1,this.subLayerEnabled.push(!0),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("add",t))}insertOpaque(t,s){if(this._isSublayerAdded(t,!1))return;this.layerList.splice(s,0,t),this.subLayerList.splice(s,0,!1);const e=this.subLayerList.length;this._updateOpaqueOrder(s,e-1),this.subLayerEnabled.splice(s,0,!0),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("add",t)}removeOpaque(t){for(let s=0,e=this.layerList.length;s<e;s++)if(this.layerList[s]===t&&!this.subLayerList[s])return this.layerList.splice(s,1),this.subLayerList.splice(s,1),e--,this._updateOpaqueOrder(s,e-1),this.subLayerEnabled.splice(s,1),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,void(this.layerList.indexOf(t)<0&&this.fire("remove",t))}pushTransparent(t){this._isSublayerAdded(t,!0)||(this.layerList.push(t),this._transparentOrder[t.id]=this.subLayerList.push(!0)-1,this.subLayerEnabled.push(!0),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("add",t))}insertTransparent(t,s){if(this._isSublayerAdded(t,!0))return;this.layerList.splice(s,0,t),this.subLayerList.splice(s,0,!0);const e=this.subLayerList.length;this._updateTransparentOrder(s,e-1),this.subLayerEnabled.splice(s,0,!0),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,this.fire("add",t)}removeTransparent(t){for(let s=0,e=this.layerList.length;s<e;s++)if(this.layerList[s]===t&&this.subLayerList[s])return this.layerList.splice(s,1),this.subLayerList.splice(s,1),e--,this._updateTransparentOrder(s,e-1),this.subLayerEnabled.splice(s,1),this._dirty=!0,this._dirtyLights=!0,this._dirtyCameras=!0,void(this.layerList.indexOf(t)<0&&this.fire("remove",t))}_getSublayerIndex(t,s){let e=this.layerList.indexOf(t);if(e<0)return-1;if(this.subLayerList[e]!==s){if(e=this.layerList.indexOf(t,e+1),e<0)return-1;if(this.subLayerList[e]!==s)return-1}return e}getOpaqueIndex(t){return this._getSublayerIndex(t,!1)}getTransparentIndex(t){return this._getSublayerIndex(t,!0)}getLayerById(t){for(let s=0;s<this.layerList.length;s++)if(this.layerList[s].id===t)return this.layerList[s];return null}getLayerByName(t){for(let s=0;s<this.layerList.length;s++)if(this.layerList[s].name===t)return this.layerList[s];return null}_updateOpaqueOrder(t,s){for(let e=t;e<=s;e++)!1===this.subLayerList[e]&&(this._opaqueOrder[this.layerList[e].id]=e)}_updateTransparentOrder(t,s){for(let e=t;e<=s;e++)!0===this.subLayerList[e]&&(this._transparentOrder[this.layerList[e].id]=e)}_sortLayersDescending(t,s,e){let r=-1,i=-1;for(let s=0,i=t.length;s<i;s++){const i=t[s];e.hasOwnProperty(i)&&(r=Math.max(r,e[i]))}for(let t=0,r=s.length;t<r;t++){const r=s[t];e.hasOwnProperty(r)&&(i=Math.max(i,e[r]))}return-1===r&&-1!==i?1:-1===i&&-1!==r?-1:i-r}sortTransparentLayers(t,s){return this._sortLayersDescending(t,s,this._transparentOrder)}sortOpaqueLayers(t,s){return this._sortLayersDescending(t,s,this._opaqueOrder)}}export{g as LayerComposition};

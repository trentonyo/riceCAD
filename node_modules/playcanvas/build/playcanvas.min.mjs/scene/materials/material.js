import{BLENDMODE_ONE as t,BLENDMODE_ZERO as e,BLENDEQUATION_ADD as s,CULLFACE_BACK as i,FUNC_LESSEQUAL as n,BLENDEQUATION_MAX as h,BLENDEQUATION_MIN as a,BLENDMODE_DST_COLOR as r,BLENDMODE_ONE_MINUS_DST_COLOR as l,BLENDMODE_SRC_COLOR as d,BLENDMODE_SRC_ALPHA as c,BLENDMODE_ONE_MINUS_SRC_ALPHA as o}from"../../platform/graphics/constants.js";import{BLEND_MAX as b,BLEND_MIN as p,BLEND_MULTIPLICATIVE as u,BLEND_SCREEN as m,BLEND_MULTIPLICATIVE2X as D,BLEND_ADDITIVEALPHA as S,BLEND_ADDITIVE as g,BLEND_PREMULTIPLIED as f,BLEND_NORMAL as q,BLEND_NONE as E}from"../constants.js";import"../../core/tracing.js";import{getDefaultMaterial as _}from"./default-material.js";import{ShaderProcessorOptions as B}from"../../platform/graphics/shader-processor-options.js";import{getProgramLibrary as y}from"../shader-lib/get-program-library.js";let I=0;class k{constructor(){this._shader=null,this.meshInstances=[],this.name="Untitled",this.id=I++,this.variants={},this.parameters={},this.alphaTest=0,this.alphaToCoverage=!1,this.blend=!1,this.blendSrc=t,this.blendDst=e,this.blendEquation=s,this.separateAlphaBlend=!1,this.blendSrcAlpha=t,this.blendDstAlpha=e,this.blendAlphaEquation=s,this.cull=i,this.depthTest=!0,this.depthFunc=n,this.depthWrite=!0,this.stencilFront=null,this.stencilBack=null,this.depthBias=0,this.slopeDepthBias=0,this.redWrite=!0,this.greenWrite=!0,this.blueWrite=!0,this.alphaWrite=!0,this._shaderVersion=0,this._scene=null,this._dirtyBlend=!1,this.dirty=!0}set shader(t){this._shader=t}get shader(){return this._shader}get transparent(){return this.blend}set blendType(i){let n=!0;switch(i){case E:n=!1,this.blendSrc=t,this.blendDst=e,this.blendEquation=s;break;case q:this.blendSrc=c,this.blendDst=o,this.blendEquation=s;break;case f:this.blendSrc=t,this.blendDst=o,this.blendEquation=s;break;case g:this.blendSrc=t,this.blendDst=t,this.blendEquation=s;break;case S:this.blendSrc=c,this.blendDst=t,this.blendEquation=s;break;case D:this.blendSrc=r,this.blendDst=d,this.blendEquation=s;break;case m:this.blendSrc=l,this.blendDst=t,this.blendEquation=s;break;case u:this.blendSrc=r,this.blendDst=e,this.blendEquation=s;break;case p:this.blendSrc=t,this.blendDst=t,this.blendEquation=a;break;case b:this.blendSrc=t,this.blendDst=t,this.blendEquation=h}this.blend!==n&&(this.blend=n,this._scene?this._scene.layers._dirtyBlend=!0:this._dirtyBlend=!0),this._updateMeshInstanceKeys()}get blendType(){return this.blend?this.blendSrc===c&&this.blendDst===o&&this.blendEquation===s?q:this.blendSrc===t&&this.blendDst===t&&this.blendEquation===s?g:this.blendSrc===c&&this.blendDst===t&&this.blendEquation===s?S:this.blendSrc===r&&this.blendDst===d&&this.blendEquation===s?D:this.blendSrc===l&&this.blendDst===t&&this.blendEquation===s?m:this.blendSrc===t&&this.blendDst===t&&this.blendEquation===a?p:this.blendSrc===t&&this.blendDst===t&&this.blendEquation===h?b:this.blendSrc===r&&this.blendDst===e&&this.blendEquation===s?u:this.blendSrc===t&&this.blendDst===o&&this.blendEquation===s?f:q:E}copy(t){return this.name=t.name,this._shader=t._shader,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.blend=t.blend,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.separateAlphaBlend=t.separateAlphaBlend,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendAlphaEquation=t.blendAlphaEquation,this.cull=t.cull,this.depthTest=t.depthTest,this.depthFunc=t.depthFunc,this.depthWrite=t.depthWrite,this.depthBias=t.depthBias,this.slopeDepthBias=t.slopeDepthBias,t.stencilFront&&(this.stencilFront=t.stencilFront.clone()),t.stencilBack&&(t.stencilFront===t.stencilBack?this.stencilBack=this.stencilFront:this.stencilBack=t.stencilBack.clone()),this.redWrite=t.redWrite,this.greenWrite=t.greenWrite,this.blueWrite=t.blueWrite,this.alphaWrite=t.alphaWrite,this}clone(){return(new this.constructor).copy(this)}_updateMeshInstanceKeys(){const t=this.meshInstances;for(let e=0;e<t.length;e++)t[e].updateKey()}updateUniforms(t,e){}getShaderVariant(t,e,s,i,n,h,a,r){const l=`shader-id-${this._shader.id}`,d=this._shader.definition,c={generateKey:function(t){return l},createShaderDefinition:function(t,e){return d}},o="shader",b=y(t);b.register(o,c);const p=new B(a,r),u=b.getProgram(o,{},p);return b.unregister(o),u}update(){this.dirty=!0,this._shader&&(this._shader.failed=!1)}clearParameters(){this.parameters={}}getParameters(){return this.parameters}clearVariants(){this.variants={};const t=this.meshInstances,e=t.length;for(let s=0;s<e;s++)t[s].clearShaders()}getParameter(t){return this.parameters[t]}setParameter(t,e){if(void 0===e&&"object"==typeof t){const s=t;if(s.length){for(let t=0;t<s.length;t++)this.setParameter(s[t]);return}t=s.name,e=s.value}const s=this.parameters[t];s?s.data=e:this.parameters[t]={scopeId:null,data:e}}deleteParameter(t){this.parameters[t]&&delete this.parameters[t]}setParameters(t,e){const s=this.parameters;void 0===e&&(e=s);for(const i in e){const e=s[i];e&&(e.scopeId||(e.scopeId=t.scope.resolve(i)),e.scopeId.setValue(e.data))}}destroy(){this.variants={},this._shader=null;for(let t=0;t<this.meshInstances.length;t++){const e=this.meshInstances[t];if(e.clearShaders(),e._material=null,e.mesh){const t=_(e.mesh.device);this!==t&&(e.material=t)}}this.meshInstances.length=0}addMeshInstanceRef(t){this.meshInstances.push(t)}removeMeshInstanceRef(t){const e=this.meshInstances,s=e.indexOf(t);-1!==s&&e.splice(s,1)}}export{k as Material};

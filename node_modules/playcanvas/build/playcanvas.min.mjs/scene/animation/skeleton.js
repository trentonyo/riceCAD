import"../../core/tracing.js";import{Quat as t}from"../../core/math/quat.js";import{Vec3 as e}from"../../core/math/vec3.js";class i{constructor(){this._written=!1,this._name="",this._keyFrames=[],this._quat=new t,this._pos=new e,this._scale=new e,this._targetNode=null}getTarget(){return this._targetNode}setTarget(t){this._targetNode=t}}class s{constructor(t){this.looping=!0,this._animation=null,this._time=0,this._interpolatedKeys=[],this._interpolatedKeyDict={},this._currKeyIndices={},this.graph=null;const e=t=>{const s=new i;s._name=t.name,this._interpolatedKeys.push(s),this._interpolatedKeyDict[t.name]=s,this._currKeyIndices[t.name]=0;for(let i=0;i<t._children.length;i++)e(t._children[i])};e(t)}set animation(t){this._animation=t,this.currentTime=0}get animation(){return this._animation}set currentTime(t){this._time=t;const e=this._interpolatedKeys.length;for(let t=0;t<e;t++){const e=this._interpolatedKeys[t]._name;this._currKeyIndices[e]=0}this.addTime(0),this.updateGraph()}get currentTime(){return this._time}get numNodes(){return this._interpolatedKeys.length}addTime(t){if(null!==this._animation){const e=this._animation._nodes,i=this._animation.duration;if(this._time===i&&!this.looping)return;if(this._time+=t,this._time>i){this._time=this.looping?0:i;for(let t=0;t<e.length;t++){const i=e[t]._name;this._currKeyIndices[i]=0}}else if(this._time<0){this._time=this.looping?i:0;for(let t=0;t<e.length;t++){const i=e[t],s=i._name;this._currKeyIndices[s]=i._keys.length-2}}const s=t>=0?1:-1;for(let t=0;t<e.length;t++){const i=e[t],n=i._name,o=i._keys,r=this._interpolatedKeyDict[n];if(void 0===r)continue;let a=!1;if(1!==o.length)for(let t=this._currKeyIndices[n];t<o.length-1&&t>=0;t+=s){const e=o[t],i=o[t+1];if(e.time<=this._time&&i.time>=this._time){const s=(this._time-e.time)/(i.time-e.time);r._pos.lerp(e.position,i.position,s),r._quat.slerp(e.rotation,i.rotation,s),r._scale.lerp(e.scale,i.scale,s),r._written=!0,this._currKeyIndices[n]=t,a=!0;break}}(1===o.length||!a&&0===this._time&&this.looping)&&(r._pos.copy(o[0].position),r._quat.copy(o[0].rotation),r._scale.copy(o[0].scale),r._written=!0)}}}blend(t,e,i){const s=this._interpolatedKeys.length;for(let n=0;n<s;n++){const s=t._interpolatedKeys[n],o=e._interpolatedKeys[n],r=this._interpolatedKeys[n];s._written&&o._written?(r._quat.slerp(s._quat,e._interpolatedKeys[n]._quat,i),r._pos.lerp(s._pos,e._interpolatedKeys[n]._pos,i),r._scale.lerp(s._scale,o._scale,i),r._written=!0):s._written?(r._quat.copy(s._quat),r._pos.copy(s._pos),r._scale.copy(s._scale),r._written=!0):o._written&&(r._quat.copy(o._quat),r._pos.copy(o._pos),r._scale.copy(o._scale),r._written=!0)}}setGraph(t){if(this.graph=t,t)for(let e=0;e<this._interpolatedKeys.length;e++){const i=this._interpolatedKeys[e],s=t.findByName(i._name);this._interpolatedKeys[e].setTarget(s)}else for(let t=0;t<this._interpolatedKeys.length;t++)this._interpolatedKeys[t].setTarget(null)}updateGraph(){if(this.graph)for(let t=0;t<this._interpolatedKeys.length;t++){const e=this._interpolatedKeys[t];if(e._written){const t=e.getTarget();t.localPosition.copy(e._pos),t.localRotation.copy(e._quat),t.localScale.copy(e._scale),t._dirtyLocal||t._dirtifyLocal(),e._written=!1}}}}export{s as Skeleton};

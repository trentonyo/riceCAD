import{PRIMITIVE_TRISTRIP as e}from"../../platform/graphics/constants.js";import{shaderChunks as t}from"../shader-lib/chunks/chunks.js";import{createShaderFromCode as s}from"../shader-lib/utils.js";import{BLEND_NORMAL as r}from"../constants.js";import{BasicMaterial as a}from"../materials/basic-material.js";import{GraphNode as h}from"../graph-node.js";import{Mesh as i}from"../mesh.js";import{MeshInstance as n}from"../mesh-instance.js";import{ImmediateBatches as o}from"./immediate-batches.js";const l=[];class d{constructor(e){this.device=e,this.quadMesh=null,this.textureShader=null,this.depthTextureShader=null,this.cubeLocalPos=null,this.cubeWorldPos=null,this.batchesMap=new Map,this.allBatches=new Set,this.updatedLayers=new Set,this._materialDepth=null,this._materialNoDepth=null,this.layerMeshInstances=new Map}createMaterial(e){const t=new a;return t.vertexColors=!0,t.blend=!0,t.blendType=r,t.depthTest=e,t.update(),t}get materialDepth(){return this._materialDepth||(this._materialDepth=this.createMaterial(!0)),this._materialDepth}get materialNoDepth(){return this._materialNoDepth||(this._materialNoDepth=this.createMaterial(!1)),this._materialNoDepth}getBatch(e,t){let s=this.batchesMap.get(e);s||(s=new o(this.device),this.batchesMap.set(e,s)),this.allBatches.add(s);const r=t?this.materialDepth:this.materialNoDepth;return s.getBatch(r,e)}static getTextureVS(){return"\n            attribute vec2 vertex_position;\n            uniform mat4 matrix_model;\n            varying vec2 uv0;\n            void main(void) {\n                gl_Position = matrix_model * vec4(vertex_position, 0, 1);\n                uv0 = vertex_position.xy + 0.5;\n            }\n        "}getTextureShader(){if(!this.textureShader){const e="\n                varying vec2 uv0;\n                uniform sampler2D colorMap;\n                void main (void) {\n                    gl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);\n                }\n            ";this.textureShader=s(this.device,d.getTextureVS(),e,"DebugTextureShader")}return this.textureShader}getDepthTextureShader(){if(!this.depthTextureShader){const e=`\n                ${t.screenDepthPS}\n                varying vec2 uv0;\n                void main() {\n                    float depth = getLinearScreenDepth(uv0) * camera_params.x;\n                    gl_FragColor = vec4(vec3(depth), 1.0);\n                }\n            `;this.depthTextureShader=s(this.device,d.getTextureVS(),e,"DebugDepthTextureShader")}return this.depthTextureShader}getQuadMesh(){return this.quadMesh||(this.quadMesh=new i(this.device),this.quadMesh.setPositions([-.5,-.5,0,.5,-.5,0,-.5,.5,0,.5,.5,0]),this.quadMesh.update(e)),this.quadMesh}drawMesh(e,t,s,r,a){if(!r){const a=this.getGraphNode(t);r=new n(s,e,a)}let h=this.layerMeshInstances.get(a);h||(h=[],this.layerMeshInstances.set(a,h)),h.push(r)}drawWireAlignedBox(e,t,s,r,a){l.push(e.x,e.y,e.z,e.x,t.y,e.z,e.x,t.y,e.z,t.x,t.y,e.z,t.x,t.y,e.z,t.x,e.y,e.z,t.x,e.y,e.z,e.x,e.y,e.z,e.x,e.y,t.z,e.x,t.y,t.z,e.x,t.y,t.z,t.x,t.y,t.z,t.x,t.y,t.z,t.x,e.y,t.z,t.x,e.y,t.z,e.x,e.y,t.z,e.x,e.y,e.z,e.x,e.y,t.z,e.x,t.y,e.z,e.x,t.y,t.z,t.x,t.y,e.z,t.x,t.y,t.z,t.x,e.y,e.z,t.x,e.y,t.z);this.getBatch(a,r).addLinesArrays(l,s),l.length=0}drawWireSphere(e,t,s,r,a,h){const i=2*Math.PI/r;let n=0;for(let s=0;s<r;s++){const s=Math.sin(n),r=Math.cos(n);n+=i;const a=Math.sin(n),h=Math.cos(n);l.push(e.x+t*s,e.y,e.z+t*r),l.push(e.x+t*a,e.y,e.z+t*h),l.push(e.x+t*s,e.y+t*r,e.z),l.push(e.x+t*a,e.y+t*h,e.z),l.push(e.x,e.y+t*s,e.z+t*r),l.push(e.x,e.y+t*a,e.z+t*h)}this.getBatch(h,a).addLinesArrays(l,s),l.length=0}getGraphNode(e){const t=new h("ImmediateDebug");return t.worldTransform=e,t._dirtyWorld=t._dirtyNormal=!1,t}onPreRenderLayer(e,t,s){if(this.batchesMap.forEach(((r,a)=>{a===e&&r.onPreRender(t,s)})),!this.updatedLayers.has(e)){this.updatedLayers.add(e);const s=this.layerMeshInstances.get(e);if(s){for(let e=0;e<s.length;e++)t.list[t.length+e]=s[e];t.length+=s.length,s.length=0}}}onPostRender(){this.allBatches.clear(),this.updatedLayers.clear()}}export{d as Immediate};

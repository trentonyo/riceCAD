import{Vec3 as t}from"../../core/math/vec3.js";import{math as s}from"../../core/math/math.js";import{BoundingBox as e}from"../../core/shape/bounding-box.js";import{PIXELFORMAT_R8_G8_B8_A8 as l}from"../../platform/graphics/constants.js";import{MASK_AFFECT_DYNAMIC as i,MASK_AFFECT_LIGHTMAPPED as u,LIGHTTYPE_DIRECTIONAL as r}from"../constants.js";import{LightsBuffer as a}from"./lights-buffer.js";import"../../core/tracing.js";const o=new t,h=new t,n=new t,c=new e;class d{constructor(){this.light=null,this.min=new t,this.max=new t}}class _{constructor(s){this.device=s,this.name="Untitled",this.reportCount=0,this.boundsMin=new t,this.boundsMax=new t,this.boundsDelta=new t,this._cells=new t(1,1,1),this._cellsLimit=new t,this.cells=this._cells,this._maxCellLightCount=0,this._pixelsPerCellCount=0,this.maxCellLightCount=4,this._maxAttenuation=0,this._maxColorValue=0,this._usedLights=[],this._usedLights.push(new d),this.lightsBuffer=new a(s),this.registerUniforms(s)}set maxCellLightCount(t){const e=s.roundUp(t,4);e!==this._maxCellLightCount&&(this._maxCellLightCount=e,this._pixelsPerCellCount=this._maxCellLightCount/4,this._cellsDirty=!0)}get maxCellLightCount(){return this._maxCellLightCount}set cells(s){o.copy(s).floor(),this._cells.equals(o)||(this._cells.copy(o),this._cellsLimit.copy(o).sub(t.ONE),this._cellsDirty=!0)}get cells(){return this._cells}destroy(){this.lightsBuffer.destroy(),this.releaseClusterTexture()}releaseClusterTexture(){this.clusterTexture&&(this.clusterTexture.destroy(),this.clusterTexture=null)}registerUniforms(t){this._clusterWorldTextureId=t.scope.resolve("clusterWorldTexture"),this._clusterPixelsPerCellId=t.scope.resolve("clusterPixelsPerCell"),this._clusterTextureSizeId=t.scope.resolve("clusterTextureSize"),this._clusterTextureSizeData=new Float32Array(3),this._clusterBoundsMinId=t.scope.resolve("clusterBoundsMin"),this._clusterBoundsMinData=new Float32Array(3),this._clusterBoundsDeltaId=t.scope.resolve("clusterBoundsDelta"),this._clusterBoundsDeltaData=new Float32Array(3),this._clusterCellsCountByBoundsSizeId=t.scope.resolve("clusterCellsCountByBoundsSize"),this._clusterCellsCountByBoundsSizeData=new Float32Array(3),this._clusterCellsDotId=t.scope.resolve("clusterCellsDot"),this._clusterCellsDotData=new Float32Array(3),this._clusterCellsMaxId=t.scope.resolve("clusterCellsMax"),this._clusterCellsMaxData=new Float32Array(3),this._clusterCompressionLimit0Id=t.scope.resolve("clusterCompressionLimit0"),this._clusterCompressionLimit0Data=new Float32Array(2)}updateParams(t){t&&(this.cells=t.cells,this.maxCellLightCount=t.maxLightsPerCell,this.lightsBuffer.cookiesEnabled=t.cookiesEnabled,this.lightsBuffer.shadowsEnabled=t.shadowsEnabled,this.lightsBuffer.areaLightsEnabled=t.areaLightsEnabled)}updateCells(){if(this._cellsDirty){this._cellsDirty=!1;const t=this._cells.x,e=this._cells.y,i=this._cells.z,u=t*e*i,r=this._pixelsPerCellCount*u;let o=Math.ceil(Math.sqrt(r));o=s.roundUp(o,this._pixelsPerCellCount);const h=Math.ceil(r/o);this._clusterCellsMaxData[0]=t,this._clusterCellsMaxData[1]=e,this._clusterCellsMaxData[2]=i,this._clusterCellsDotData[0]=this._pixelsPerCellCount,this._clusterCellsDotData[1]=t*i*this._pixelsPerCellCount,this._clusterCellsDotData[2]=t*this._pixelsPerCellCount,this.clusters=new Uint8ClampedArray(4*r),this.counts=new Int32Array(u),this._clusterTextureSizeData[0]=o,this._clusterTextureSizeData[1]=1/o,this._clusterTextureSizeData[2]=1/h,this.releaseClusterTexture(),this.clusterTexture=a.createTexture(this.device,o,h,l,"ClusterTexture")}}uploadTextures(){this.clusterTexture.lock().set(this.clusters),this.clusterTexture.unlock(),this.lightsBuffer.uploadTextures()}updateUniforms(){this.lightsBuffer.updateUniforms(),this._clusterWorldTextureId.setValue(this.clusterTexture);const t=this.boundsDelta;this._clusterCellsCountByBoundsSizeData[0]=this._cells.x/t.x,this._clusterCellsCountByBoundsSizeData[1]=this._cells.y/t.y,this._clusterCellsCountByBoundsSizeData[2]=this._cells.z/t.z,this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData),this._clusterBoundsMinData[0]=this.boundsMin.x,this._clusterBoundsMinData[1]=this.boundsMin.y,this._clusterBoundsMinData[2]=this.boundsMin.z,this._clusterBoundsDeltaData[0]=t.x,this._clusterBoundsDeltaData[1]=t.y,this._clusterBoundsDeltaData[2]=t.z,this._clusterCompressionLimit0Data[0]=this._maxAttenuation,this._clusterCompressionLimit0Data[1]=this._maxColorValue,this._clusterPixelsPerCellId.setValue(this._pixelsPerCellCount),this._clusterTextureSizeId.setValue(this._clusterTextureSizeData),this._clusterBoundsMinId.setValue(this._clusterBoundsMinData),this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData),this._clusterCellsDotId.setValue(this._clusterCellsDotData),this._clusterCellsMaxId.setValue(this._clusterCellsMaxData),this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data)}evalLightCellMinMax(s,e,l){e.copy(s.min),e.sub(this.boundsMin),e.div(this.boundsDelta),e.mul2(e,this.cells),e.floor(),l.copy(s.max),l.sub(this.boundsMin),l.div(this.boundsDelta),l.mul2(l,this.cells),l.ceil(),e.max(t.ZERO),l.min(this._cellsLimit)}collectLights(t){const s=this.lightsBuffer.maxLights,e=this._usedLights;let l=1;t.forEach((t=>{const a=!!(t.mask&(i|u));if(t.enabled&&t.type!==r&&t.visibleThisFrame&&t.intensity>0&&a&&l<s){let s;l<e.length?s=e[l]:(s=new d,e.push(s)),s.light=t,t.getBoundingBox(c),s.min.copy(c.getMin()),s.max.copy(c.getMax()),l++}})),e.length=l}evaluateBounds(){const t=this._usedLights,s=this.boundsMin,e=this.boundsMax;if(t.length>1){s.copy(t[1].min),e.copy(t[1].max);for(let l=2;l<t.length;l++)s.min(t[l].min),e.max(t[l].max)}else s.set(0,0,0),e.set(1,1,1);this.boundsDelta.sub2(e,s),this.lightsBuffer.setBounds(s,this.boundsDelta)}evaluateCompressionLimits(t){let s=0,e=0;const l=this._usedLights;for(let i=1;i<l.length;i++){const u=l[i].light;s=Math.max(u.attenuationEnd,s);const r=t?u._linearFinalColor:u._finalColor;e=Math.max(r[0],e),e=Math.max(r[1],e),e=Math.max(r[2],e)}this._maxAttenuation=s+1e-6,this._maxColorValue=e+1e-6,this.lightsBuffer.setCompressionRanges(this._maxAttenuation,this._maxColorValue)}updateClusters(t){this.counts.fill(0),this.clusters.fill(0);const s=this._cells.x,e=this._cells.z,l=this.counts,i=this._maxCellLightCount,u=this.clusters,r=this._pixelsPerCellCount,a=this._usedLights;for(let o=1;o<a.length;o++){const c=a[o],d=c.light;this.lightsBuffer.addLightData(d,o,t),this.evalLightCellMinMax(c,h,n);const _=h.x,C=n.x,x=h.y,m=n.y,p=h.z,D=n.z;for(let t=_;t<=C;t++)for(let a=p;a<=D;a++)for(let h=x;h<=m;h++){const n=t+s*(a+h*e),c=l[n];c<i&&(u[r*n*4+c]=o,l[n]=c+1)}}}update(t,s,e){this.updateParams(e),this.updateCells(),this.collectLights(t),this.evaluateBounds(),this.evaluateCompressionLimits(s),this.updateClusters(s),this.uploadTextures()}activate(){this.updateUniforms()}}export{_ as WorldClusters};

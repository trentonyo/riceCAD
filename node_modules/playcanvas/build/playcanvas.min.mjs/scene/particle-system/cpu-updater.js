import{math as t}from"../../core/math/math.js";import{Mat4 as e}from"../../core/math/mat4.js";import{Vec3 as a}from"../../core/math/vec3.js";import{EMITTERSHAPE_BOX as o,EMITTERSHAPE_SPHERE as l,PARTICLESORT_NONE as c}from"../constants.js";let n,r=1;const s=new e,i=new e,m=new a,u=new a,P=new a,y=new a,d=new a,p=new a,h=new a,x=new a,z=new a,q=new a,M=new a,S=new a,V=new a;function f(t){return t-Math.floor(t)}function w(t,e){return t-e*Math.floor(t/e)}function b(t){let e=f(t),a=f(255*t);return e-=a/255,a-=a/255,[e,a]}class R{constructor(t){this._emitter=t}calcSpawnPosition(e,a,l,c,n){const r=this._emitter,s=Math.random(),i=Math.random(),P=Math.random(),y=Math.random();if(r.useCpu&&(e[4*n+0+2*r.numParticlesPot*4]=s,e[4*n+1+2*r.numParticlesPot*4]=i,e[4*n+2+2*r.numParticlesPot*4]=P),u.x=s-.5,u.y=i-.5,u.z=P-.5,r.emitterShape===o){const t=Math.max(Math.abs(u.x),Math.max(Math.abs(u.y),Math.abs(u.z))),e=t+(.5-t)*l[0],o=t+(.5-t)*l[1],n=t+(.5-t)*l[2];u.x=e*(t===Math.abs(u.x)?Math.sign(u.x):2*u.x),u.y=o*(t===Math.abs(u.y)?Math.sign(u.y):2*u.y),u.z=n*(t===Math.abs(u.z)?Math.sign(u.z):2*u.z),r.localSpace?m.copy(a.transformPoint(u)):m.copy(c).add(a.transformPoint(u))}else{u.normalize();const t=0===r.emitterRadius?0:r.emitterRadiusInner/r.emitterRadius,e=y*(1-t)+t;r.localSpace?m.copy(u.mulScalar(e*r.emitterRadius)):m.copy(c).add(u.mulScalar(e*r.emitterRadius))}let d=-t.lerp(r.rate,r.rate2,s)*n;if(r.pack8){const a=(m.x-r.worldBounds.center.x)/r.worldBoundsSize.x+.5,o=(m.y-r.worldBounds.center.y)/r.worldBoundsSize.y+.5,l=(m.z-r.worldBounds.center.z)/r.worldBoundsSize.z+.5;let c=t.lerp(r.startAngle*t.DEG_TO_RAD,r.startAngle2*t.DEG_TO_RAD,s);c=c%(2*Math.PI)/(2*Math.PI);const i=b(a);e[4*n]=i[0],e[4*n+1]=i[1];const u=b(o);e[4*n+2]=u[0],e[4*n+3]=u[1];const P=b(l);e[4*n+0+4*r.numParticlesPot]=P[0],e[4*n+1+4*r.numParticlesPot]=P[1];const y=b(c);e[4*n+2+4*r.numParticlesPot]=y[0],e[4*n+3+4*r.numParticlesPot]=y[1];const p=1;e[4*n+3+4*r.numParticlesPot*2]=p;const h=Math.max(r.lifetime,(r.numParticles-1)*Math.max(r.rate,r.rate2));d=(d+h)/(h+(r.lifetime+1));const x=function(t){let e=f(t),a=f(255*t),o=f(65025*t),l=f(160581375*t);return e-=a/255,a-=o/255,o-=l/255,l-=l/255,[e,a,o,l]}(d);e[4*n+0+4*r.numParticlesPot*3]=x[0],e[4*n+1+4*r.numParticlesPot*3]=x[1],e[4*n+2+4*r.numParticlesPot*3]=x[2],e[4*n+3+4*r.numParticlesPot*3]=x[3]}else e[4*n]=m.x,e[4*n+1]=m.y,e[4*n+2]=m.z,e[4*n+3]=t.lerp(r.startAngle*t.DEG_TO_RAD,r.startAngle2*t.DEG_TO_RAD,s),e[4*n+3+4*r.numParticlesPot]=d}update(t,e,o,m,f,b,R,v){let A,B,D;const L=this._emitter;if(L.meshInstance.node){const t=L.meshInstance.node.worldTransform;for(let e=0;e<12;e++)s.data[e]=t.data[e];i.copy(s),i.invert(),n=L.meshInstance.node.localScale,r=Math.max(Math.max(n.x,n.y),n.z)}b=null===L.meshInstance.node||L.localSpace?a.ZERO:L.meshInstance.node.getPosition();const _=L.camera?L.camera._node.getPosition():a.ZERO,C=L.useMesh?17:15;let g,O,U,I,E,T,j,G,Z;const k=L.precision-1;for(let e=0;e<L.numParticles;e++){const c=Math.floor(L.vbCPU[e*L.numParticleVerts*(L.useMesh?6:4)+3]),N=o[4*c+0+2*L.numParticlesPot*4];P.x=N,P.y=o[4*c+1+2*L.numParticlesPot*4],P.z=o[4*c+2+2*L.numParticlesPot*4];const W=L.rate+(L.rate2-L.rate)*N,H=L.lifetime;let J=o[4*c+3+4*L.numParticlesPot]+R;const K=(F=J/H,Math.max(Math.min(F,1),0));let Q=0,X=0;const Y=0;(J-R<=0||J>=H)&&this.calcSpawnPosition(o,m,f,b,c);let $=J>0&&J<H;$&&(D=K*k,g=Math.floor(D),O=Math.ceil(D),D%=1,A=L.qRotSpeed[g],B=L.qRotSpeed[O],U=A+(B-A)*D,A=L.qRotSpeed2[g],B=L.qRotSpeed2[O],I=A+(B-A)*D,A=L.qScale[g],B=L.qScale[O],Q=A+(B-A)*D,A=L.qScale2[g],B=L.qScale2[O],E=A+(B-A)*D,A=L.qAlpha[g],B=L.qAlpha[O],T=A+(B-A)*D,A=L.qAlpha2[g],B=L.qAlpha2[O],j=A+(B-A)*D,A=L.qRadialSpeed[g],B=L.qRadialSpeed[O],G=A+(B-A)*D,A=L.qRadialSpeed2[g],B=L.qRadialSpeed2[O],Z=A+(B-A)*D,G+=100*N%1*(Z-G),y.x=o[4*c],y.y=o[4*c+1],y.z=o[4*c+2],L.localSpace?z.copy(y):z.copy(y).sub(b),z.normalize().mulScalar(G),g*=3,O*=3,A=L.qLocalVelocity[g],B=L.qLocalVelocity[O],p.x=A+(B-A)*D,A=L.qLocalVelocity[g+1],B=L.qLocalVelocity[O+1],p.y=A+(B-A)*D,A=L.qLocalVelocity[g+2],B=L.qLocalVelocity[O+2],p.z=A+(B-A)*D,A=L.qLocalVelocity2[g],B=L.qLocalVelocity2[O],x.x=A+(B-A)*D,A=L.qLocalVelocity2[g+1],B=L.qLocalVelocity2[O+1],x.y=A+(B-A)*D,A=L.qLocalVelocity2[g+2],B=L.qLocalVelocity2[O+2],x.z=A+(B-A)*D,A=L.qVelocity[g],B=L.qVelocity[O],d.x=A+(B-A)*D,A=L.qVelocity[g+1],B=L.qVelocity[O+1],d.y=A+(B-A)*D,A=L.qVelocity[g+2],B=L.qVelocity[O+2],d.z=A+(B-A)*D,A=L.qVelocity2[g],B=L.qVelocity2[O],h.x=A+(B-A)*D,A=L.qVelocity2[g+1],B=L.qVelocity2[O+1],h.y=A+(B-A)*D,A=L.qVelocity2[g+2],B=L.qVelocity2[O+2],h.z=A+(B-A)*D,p.x+=(x.x-p.x)*P.x,p.y+=(x.y-p.y)*P.y,p.z+=(x.z-p.z)*P.z,L.initialVelocity>0&&(L.emitterShape===l?(u.copy(P).mulScalar(2).sub(a.ONE).normalize(),p.add(u.mulScalar(L.initialVelocity))):p.add(a.FORWARD.mulScalar(L.initialVelocity))),d.x+=(h.x-d.x)*P.x,d.y+=(h.y-d.y)*P.y,d.z+=(h.z-d.z)*P.z,U+=(I-U)*P.y,Q=(Q+1e4*N%1*(E-Q))*r,X=1e3*N%1*(j-T),L.meshInstance.node&&(L.localSpace?(p.x/=n.x,p.y/=n.y,p.z/=n.z):s.transformPoint(p,p)),L.localSpace?(i.transformPoint(d,d),p.add(d).add(z)):(p.add(d.mul(n)),p.add(z.mul(n))),S.copy(p),q.copy(y).add(p.mulScalar(R)),M.copy(q),o[4*c]=M.x,o[4*c+1]=M.y,o[4*c+2]=M.z,o[4*c+3]+=U*R,L.wrap&&L.wrapBounds&&(L.localSpace||M.sub(b),M.x=w(M.x,L.wrapBounds.x)-.5*L.wrapBounds.x,M.y=w(M.y,L.wrapBounds.y)-.5*L.wrapBounds.y,M.z=w(M.z,L.wrapBounds.z)-.5*L.wrapBounds.z,L.localSpace||M.add(b)),L.sort>0&&(1===L.sort?(V.copy(M).sub(_),L.particleDistance[c]=-(V.x*V.x+V.y*V.y+V.z*V.z)):2===L.sort?L.particleDistance[c]=J:3===L.sort&&(L.particleDistance[c]=-J))),v?J<0&&(o[4*c+3+2*L.numParticlesPot*4]=-1):(J>=H&&(J-=Math.max(H,(L.numParticles-1)*W),o[4*c+3+2*L.numParticlesPot*4]=L.loop?1:-1),J<0&&L.loop&&(o[4*c+3+2*L.numParticlesPot*4]=1)),o[4*c+3+2*L.numParticlesPot*4]<0&&($=!1),o[4*c+3+4*L.numParticlesPot]=J;for(let a=0;a<L.numParticleVerts;a++){const l=(e*L.numParticleVerts+a)*(L.useMesh?6:4);let n=L.vbCPU[l],r=L.vbCPU[l+1],s=L.vbCPU[l+2];$||(n=r=s=0);const i=e*L.numParticleVerts*C+a*C;t[i]=M.x,t[i+1]=M.y,t[i+2]=M.z,t[i+3]=K,t[i+4]=L.alignToMotion?Y:o[4*c+3],t[i+5]=Q,t[i+6]=X,t[i+7]=S.x,t[i+8]=n,t[i+9]=r,t[i+10]=s,t[i+11]=S.y,t[i+12]=c,t[i+13]=S.z,t[i+14]=L.vbCPU[l+3],L.useMesh&&(t[i+15]=L.vbCPU[l+4],t[i+16]=L.vbCPU[l+5])}}var F;if(L.sort>c&&L.camera){const t=L.useMesh?6:4,a=L.particleDistance;for(let o=0;o<L.numParticles;o++)e[o][0]=o,e[o][1]=a[Math.floor(L.vbCPU[o*L.numParticleVerts*t+3])];L.vbOld.set(L.vbCPU),e.sort((function(t,e){return t[1]-e[1]}));for(let a=0;a<L.numParticles;a++){const o=e[a][0]*L.numParticleVerts*t,l=a*L.numParticleVerts*t;for(let e=0;e<L.numParticleVerts*t;e++)L.vbCPU[l+e]=L.vbOld[o+e]}}}}export{R as ParticleCPUUpdater};

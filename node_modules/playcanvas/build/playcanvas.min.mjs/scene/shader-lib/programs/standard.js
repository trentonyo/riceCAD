import{hashCode as e}from"../../../core/hash.js";import"../../../core/tracing.js";import{LIGHTTYPE_DIRECTIONAL as a,SPRITE_RENDERMODE_SLICED as n,SPRITE_RENDERMODE_TILED as t,SPECULAR_PHONG as p,FRESNEL_SCHLICK as s,BLEND_NONE as d}from"../../constants.js";import{ShaderPass as i}from"../../shader-pass.js";import{LitShader as r}from"./lit-shader.js";import{ChunkBuilder as o}from"../chunk-builder.js";import{ChunkUtils as c}from"../chunk-utils.js";const l=[],h={optionsContext:{},optionsContextMin:{},generateKey:function(n){const t=function(e){const a=[];for(const n in e)e.hasOwnProperty(n)&&"chunks"!==n&&"lights"!==n&&a.push(n);return a.sort()};let p;n===this.optionsContextMin?(this.propsMin||(this.propsMin=t(n)),p=this.propsMin):n===this.optionsContext?(this.props||(this.props=t(n)),p=this.props):p=t(n);let s="standard";for(let e=0;e<p.length;e++)n[p[e]]&&(s+=p[e]+n[p[e]]);if(n.chunks){const e=[];for(const a in n.chunks)n.chunks.hasOwnProperty(a)&&e.push(a+n.chunks[a]);e.sort(),s+=e}if(n.lights){const e=n.clusteredLightingEnabled;for(let t=0;t<n.lights.length;t++){const p=n.lights[t];e&&p._type!==a||(s+=p.key)}}return e(s)},_getUvSourceExpression:function(e,a,p){const s=p[e],d=p[a],r=i.isForward(p.pass);let o;return r&&p.nineSlicedMode===n||r&&p.nineSlicedMode===t?o="nineSlicedUv":(o=0===s?"vUv"+d:"vUV"+d+"_"+s,p.heightMap&&"heightMapTransform"!==e&&(o+=" + dUvOffset")),o},_addMapDef:function(e,a){return a?`#define ${e}\n`:`#undef ${e}\n`},_addMapDefs:function(e,a,n,t){return this._addMapDef("MAPFLOAT",e)+this._addMapDef("MAPCOLOR",a)+this._addMapDef("MAPVERTEX",n)+this._addMapDef("MAPTEXTURE",t)},_addMap:function(e,a,n,t,p,s=null){const d=e+"Map",i=d+"Uv",r=d+"Identifier",o=d+"Transform",l=d+"Channel",h=e+"VertexColorChannel",u=e+"VertexColor",f=e+"Mode",g=n[e+"Tint"],M=n[u],m=n[d],S=n[r],k=n[f];let _=t[a];if(m){const e=this._getUvSourceExpression(o,i,n);if(_=_.replace(/\$UV/g,e).replace(/\$CH/g,n[l]),p&&-1!==_.search(/\$SAMPLER/g)){let e="texture_"+d;const a=p[S];a?e=a:p[S]=e,_=_.replace(/\$SAMPLER/g,e)}if(s&&(_="aaa"===n[l]?_.replace(/\$DECODE/g,"passThrough"):_.replace(/\$DECODE/g,c.decodeFunc(n.gamma||"srgb"!==s?s:"linear")),_.indexOf("$texture2DSAMPLE"))){const e={linear:"texture2D",srgb:"texture2DSRGB",rgbm:"texture2DRGBM",rgbe:"texture2DRGBE"};_=_.replace(/\$texture2DSAMPLE/g,e[s]||"texture2D")}}M&&(_=_.replace(/\$VC/g,n[h])),k&&(_=_.replace(/\$DETAILMODE/g,k));const C=!!(1&g),P=!!(2&g);return _=this._addMapDefs(C,P,M,m)+_,_.replace(/\$/g,"")},_correctChannel:function(e,a,n){if(n[e]>0){if(n[e]<a.length)return a.substring(0,n[e]);if(n[e]>a.length){let t=a;const p=t.charAt(t.length-1),s=n[e]-t.length;for(let e=0;e<s;e++)t+=p;return t}return a}},createShaderDefinition:function(e,a){const n=new r(e,a),c=[],h=[],u=[],f={};for(const e in l){const n=e+"Map";if(a[e+"VertexColor"]){const n=e+"VertexColorChannel";a[n]=this._correctChannel(e,a[n],l)}if(a[n]){const t=n+"Channel",p=n+"Transform",s=n+"Uv";a[s]=Math.min(a[s],1),a[t]=this._correctChannel(e,a[t],l);const d=a[s];c[d]=!0,h[d]=h[d]||a[n]&&!a[p],a[p]&&u.push({name:e,id:a[p],uv:a[s]})}}a.forceUv1&&(c[1]=!0,h[1]=void 0===h[1]||h[1]),n.generateVertexShader(c,h,u),a.shadingModel===p?(a.fresnelModel=0,a.ambientSH=!1):a.fresnelModel=0===a.fresnelModel?s:a.fresnelModel;const g=new o,M=new o,m=new o;let S="";if(a.nineSlicedMode===t?g.append("const float textureBias = -1000.0;"):g.append("uniform float textureBias;"),i.isForward(a.pass)){if(a.heightMap&&(g.append("vec2 dUvOffset;"),M.append(this._addMap("height","parallaxPS",a,n.chunks,f)),m.append("getParallax();")),a.blendType!==d||a.alphaTest||a.alphaToCoverage?(g.append("float dAlpha;"),M.append(this._addMap("opacity","opacityPS",a,n.chunks,f)),m.append("getOpacity();"),a.alphaTest&&(M.append(n.chunks.alphaTestPS),m.append("alphaTest(dAlpha);"))):g.append("float dAlpha = 1.0;"),n.needsNormal){if((a.normalMap||a.clearCoatNormalMap)&&(M.append(a.packedNormal?n.chunks.normalXYPS:n.chunks.normalXYZPS),!a.hasTangents)){const e=a.normalMap?"normalMap":"clearCoatNormalMap";S=this._getUvSourceExpression(`${e}Transform`,`${e}Uv`,a)}g.append("vec3 dNormalW;"),M.append(this._addMap("normalDetail","normalDetailMapPS",a,n.chunks,f)),M.append(this._addMap("normal","normalMapPS",a,n.chunks,f)),m.append("getNormal();")}if(n.needsSceneColor&&g.append("uniform sampler2D uSceneColorMap;"),n.needsScreenSize&&g.append("uniform vec4 uScreenSize;"),n.needsTransforms&&(g.append("uniform mat4 matrix_viewProjection;"),g.append("uniform mat4 matrix_model;")),g.append("vec3 dAlbedo;"),a.diffuseDetail&&M.append(this._addMap("diffuseDetail","diffuseDetailMapPS",a,n.chunks,f,a.diffuseDetailEncoding)),M.append(this._addMap("diffuse","diffusePS",a,n.chunks,f,a.diffuseEncoding)),m.append("getAlbedo();"),a.refraction&&(g.append("float dTransmission;"),M.append(this._addMap("refraction","transmissionPS",a,n.chunks,f)),m.append("getRefraction();"),g.append("float dThickness;"),M.append(this._addMap("thickness","thicknessPS",a,n.chunks,f)),m.append("getThickness();")),a.iridescence&&(g.append("vec3 dIridescenceFresnel;"),g.append("float dIridescence;"),M.append(this._addMap("iridescence","iridescencePS",a,n.chunks,f)),m.append("getIridescence();"),g.append("float dIridescenceThickness;"),M.append(this._addMap("iridescenceThickness","iridescenceThicknessPS",a,n.chunks,f)),m.append("getIridescenceThickness();")),n.lighting&&a.useSpecular||n.reflections?(g.append("vec3 dSpecularity;"),g.append("float dGlossiness;"),a.sheen&&(g.append("vec3 sSpecularity;"),M.append(this._addMap("sheen","sheenPS",a,n.chunks,f,a.sheenEncoding)),m.append("getSheen();"),g.append("float sGlossiness;"),M.append(this._addMap("sheenGlossiness","sheenGlossPS",a,n.chunks,f)),m.append("getSheenGlossiness();")),a.useMetalness&&(g.append("float dMetalness;"),M.append(this._addMap("metalness","metalnessPS",a,n.chunks,f)),m.append("getMetalness();")),a.useSpecularityFactor&&(g.append("float dSpecularityFactor;"),M.append(this._addMap("specularityFactor","specularityFactorPS",a,n.chunks,f)),m.append("getSpecularityFactor();")),a.useSpecularColor?M.append(this._addMap("specular","specularPS",a,n.chunks,f,a.specularEncoding)):M.append("void getSpecularity() { dSpecularity = vec3(1); }"),M.append(this._addMap("gloss","glossPS",a,n.chunks,f)),m.append("getGlossiness();"),m.append("getSpecularity();")):(g.append("vec3 dSpecularity = vec3(0.0);"),g.append("float dGlossiness = 0.0;")),(a.aoMap||a.aoVertexColor)&&(g.append("float dAo;"),M.append(this._addMap("ao","aoPS",a,n.chunks,f)),m.append("getAO();")),g.append("vec3 dEmission;"),M.append(this._addMap("emissive","emissivePS",a,n.chunks,f,a.emissiveEncoding)),m.append("getEmission();"),a.clearCoat>0&&(g.append("float ccSpecularity;"),g.append("float ccGlossiness;"),g.append("vec3 ccNormalW;"),M.append(this._addMap("clearCoat","clearCoatPS",a,n.chunks,f)),M.append(this._addMap("clearCoatGloss","clearCoatGlossPS",a,n.chunks,f)),M.append(this._addMap("clearCoatNormal","clearCoatNormalPS",a,n.chunks,f)),m.append("getClearCoat();"),m.append("getClearCoatGlossiness();"),m.append("getClearCoatNormal();")),a.lightMap||a.lightVertexColor){const e=a.dirLightMap&&a.useSpecular,t=e?"lightmapDirPS":"lightmapSinglePS";g.append("vec3 dLightmap;"),e&&g.append("vec3 dLightmapDir;"),M.append(this._addMap("light",t,a,n.chunks,f,a.lightMapEncoding)),m.append("getLightMap();")}-1===M.code.indexOf("texture2DSRGB")&&-1===M.code.indexOf("texture2DRGBM")&&-1===M.code.indexOf("texture2DRGBE")||M.prepend(n.chunks.textureSamplePS)}else a.alphaTest&&(g.append("float dAlpha;"),M.append(this._addMap("opacity","opacityPS",a,n.chunks,f)),M.append(n.chunks.alphaTestPS),m.append("getOpacity();"),m.append("alphaTest(dAlpha);"));for(const e in f)g.append(`uniform sampler2D ${f[e]};`);return m.code=`\n${m.code.split("\n").map((e=>`    ${e}`)).join("\n")}\n\n`,n.generateFragmentShader(g.code,M.code,m.code,S),n.getDefinition()}};export{l as _matTex2D,h as standard};

import"../../core/tracing.js";import{version as e,revision as t}from"../../core/core.js";import{Shader as s}from"../../platform/graphics/shader.js";import{SHADER_FORWARD as i,SHADER_SHADOW as r,SHADER_DEPTH as a,SHADER_PICK as o}from"../constants.js";import{ShaderPass as n}from"../shader-pass.js";class h{constructor(e,t){this.processedCache=new Map,this.definitionsCache=new Map,this._device=e,this._generators={},this._isClearingCache=!1,this._precached=!1,this._programsCollection=[],this._defaultStdMatOption={},this._defaultStdMatOptionMin={},t.shaderOptBuilder.updateRef(this._defaultStdMatOption,{},t,null,[],i,null),t.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin,{},t,null,[],r,null),e.on("destroy:shader",(e=>{this.removeFromCache(e)}))}destroy(){this.clearCache()}register(e,t){this.isRegistered(e)||(this._generators[e]=t)}unregister(e){this.isRegistered(e)&&delete this._generators[e]}isRegistered(e){return void 0!==this._generators[e]}generateShaderDefinition(e,t,s,i){let r=this.definitionsCache.get(s);if(!r){let a;i.lights&&(a=i.lights,i.lights=a.map((function(e){const t=e.clone?e.clone():e;return t.key=e.key,t}))),this.storeNewProgram(t,i),i.lights&&(i.lights=a),this._precached;const o=this._device;r=e.createShaderDefinition(o,i),r.name=`${t}-pass:${i.pass}`,this.definitionsCache.set(s,r)}return r}getCachedShader(e){return this.processedCache.get(e)}setCachedShader(e,t){this.processedCache.set(e,t)}getProgram(e,t,i){const r=this._generators[e];if(!r)return null;const a=r.generateKey(t),o=`${a}#${JSON.stringify(i)}`;let n=this.getCachedShader(o);if(!n){const h=this.generateShaderDefinition(r,e,a,t),c={name:e,attributes:h.attributes,vshader:h.vshader,fshader:h.fshader,processingOptions:i};n=new s(this._device,c),this.setCachedShader(o,n)}return n}storeNewProgram(e,t){let s={};if("standard"===e){const e=this._getDefaultStdMatOptions(t.pass);for(const i in t)(t.hasOwnProperty(i)&&e[i]!==t[i]||"pass"===i)&&(s[i]=t[i])}else s=t;this._programsCollection.push(JSON.stringify({name:e,options:s}))}dumpPrograms(){let s="let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n";s+="let shaders = [",this._programsCollection[0]&&(s+="\n\t"+this._programsCollection[0]);for(let e=1;e<this._programsCollection.length;++e)s+=",\n\t"+this._programsCollection[e];s+="\n];\n",s+="device.getProgramLibrary().precompile(shaders);\n",s+='if (pc.version != "'+e+'" || pc.revision != "'+t+'")\n',s+='\tconsole.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");';const i=document.createElement("a");i.setAttribute("href","data:text/plain;charset=utf-8,"+encodeURIComponent(s)),i.setAttribute("download","precompile-shaders.js"),i.style.display="none",document.body.appendChild(i),i.click(),document.body.removeChild(i)}clearCache(){this._isClearingCache=!0,this.processedCache.forEach((e=>{e.destroy()})),this.processedCache.clear(),this._isClearingCache=!1}removeFromCache(e){this._isClearingCache||this.processedCache.forEach(((t,s)=>{e===t&&this.processedCache.delete(s)}))}_getDefaultStdMatOptions(e){return e===a||e===o||n.isShadow(e)?this._defaultStdMatOptionMin:this._defaultStdMatOption}precompile(e){if(e){const t=new Array(e.length);for(let s=0;s<e.length;s++){if("standard"===e[s].name){const t=e[s].options,i=this._getDefaultStdMatOptions(t.pass);for(const e in i)i.hasOwnProperty(e)&&void 0===t[e]&&(t[e]=i[e])}t[s]=this.getProgram(e[s].name,e[s].options)}}this._precached=!0}}export{h as ProgramLibrary};

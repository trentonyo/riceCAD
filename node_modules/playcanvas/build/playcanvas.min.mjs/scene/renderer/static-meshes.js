import"../../core/time.js";import{Vec3 as e}from"../../core/math/vec3.js";import{Mat4 as t}from"../../core/math/mat4.js";import{BoundingBox as r}from"../../core/shape/bounding-box.js";import{BoundingSphere as s}from"../../core/shape/bounding-sphere.js";import{SEMANTIC_POSITION as o,PRIMITIVE_TRIANGLES as i}from"../../platform/graphics/constants.js";import{IndexBuffer as n}from"../../platform/graphics/index-buffer.js";import{LIGHTTYPE_SPOT as a,LIGHTTYPE_OMNI as c}from"../constants.js";import{Mesh as l}from"../mesh.js";import{MeshInstance as m}from"../mesh-instance.js";const h=new s;class f{static lightCompare(e,t){return e.key-t.key}static prepare(s,p,u,g){const d=u,A=d.length,_=[],b=new e,L=new e,w=new r,y=new t,S=[],x=[],M=[],U=[];for(let e=0;e<A;e++){const t=d[e];if(t.isStatic){const e=t.aabb;U.length=0;for(let s=c;s<=a;s++)for(let o=0;o<g.length;o++){const i=g[o];if(i._type===s&&(i.enabled&&i.mask&t.mask&&i.isStatic)){if(x[o]||(x[o]=new r,i._node.getWorldTransform(),i.getBoundingSphere(h),x[o].center.copy(h.center),x[o].halfExtents.set(h.radius,h.radius,h.radius)),!x[o].intersects(e))continue;U.push(o)}}if(0===U.length){_.push(t);continue}const p=t.mesh,u=p.vertexBuffer,d=p.indexBuffer[t.renderStyle],A=2===d.bytesPerIndex?new Uint16Array(d.lock()):new Uint32Array(d.lock()),v=p.primitive[t.renderStyle].count/3,k=p.primitive[t.renderStyle].base,E=u.format.elements,N=u.format.size/4,V=new Float32Array(u.storage);let X;for(let e=0;e<E.length;e++)E[e].name===o&&(X=E[e].offset/4);S.length=v;for(let e=0;e<v;e++)S[e]=0;let j=!1;M.length=6*v;for(let e=0;e<v;e++){let t=Number.MAX_VALUE,r=Number.MAX_VALUE,s=Number.MAX_VALUE,o=-Number.MAX_VALUE,i=-Number.MAX_VALUE,n=-Number.MAX_VALUE;for(let a=0;a<3;a++){let c=A[3*e+a+k];c=c*N+X;const l=V[c],m=V[c+1],h=V[c+2];l<t&&(t=l),m<r&&(r=m),h<s&&(s=h),l>o&&(o=l),m>i&&(i=m),h>n&&(n=h)}const a=6*e;M[a]=t,M[a+1]=r,M[a+2]=s,M[a+3]=o,M[a+4]=i,M[a+5]=n}for(let e=0;e<U.length;e++){const r=U[e];y.copy(t.node.worldTransform).invert(),w.setFromTransformedAabb(x[r],y);const s=w.getMin(),o=w.getMax(),i=1<<e;for(let e=0;e<v;e++){const t=6*e;M[t]<=o.x&&M[t+3]>=s.x&&M[t+1]<=o.y&&M[t+4]>=s.y&&M[t+2]<=o.z&&M[t+5]>=s.z&&(S[e]|=i,j=!0)}}if(j){const e={};for(let t=0;t<v;t++){const r=3*t+k,s=S[t];e[s]||(e[s]=[]);const o=e[s];o.push(A[r]),o.push(A[r+1]),o.push(A[r+2])}for(const o in e){const a=e[o],c=new n(s,d.format,a.length,d.usage);(2===c.bytesPerIndex?new Uint16Array(c.lock()):new Uint32Array(c.lock())).set(a),c.unlock();let h=Number.MAX_VALUE,p=Number.MAX_VALUE,A=Number.MAX_VALUE,w=-Number.MAX_VALUE,y=-Number.MAX_VALUE,S=-Number.MAX_VALUE;for(let e=0;e<a.length;e++){const t=a[e],r=V[t*N+X],s=V[t*N+X+1],o=V[t*N+X+2];r<h&&(h=r),s<p&&(p=s),o<A&&(A=o),r>w&&(w=r),s>y&&(y=s),o>S&&(S=o)}b.set(h,p,A),L.set(w,y,S);const x=new r;x.setMinMax(b,L);const M=new l(s);M.vertexBuffer=u,M.indexBuffer[0]=c,M.primitive[0].type=i,M.primitive[0].base=0,M.primitive[0].count=a.length,M.primitive[0].indexed=!0,M.aabb=x;const v=new m(M,t.material,t.node);v.isStatic=t.isStatic,v.visible=t.visible,v.layer=t.layer,v.castShadow=t.castShadow,v._receiveShadow=t._receiveShadow,v.cull=t.cull,v.pick=t.pick,v.mask=t.mask,v.parameters=t.parameters,v._shaderDefs=t._shaderDefs,v._staticSource=t,t._staticLightList?v._staticLightList=t._staticLightList:v._staticLightList=[];for(let e=0;e<U.length;e++){if(o&1<<e){const t=g[U[e]];v._staticLightList.indexOf(t)<0&&v._staticLightList.push(t)}}v._staticLightList.sort(f.lightCompare),_.push(v)}}else _.push(t)}else _.push(t)}u.length=_.length;for(let e=0;e<_.length;e++)u[e]=_[e]}static revert(e){const t=e,r=t.length,s=[];let o;for(let e=0;e<r;e++){const r=t[e];r._staticSource?r._staticSource!==o&&(s.push(r._staticSource),o=r._staticSource):s.push(r)}e.length=s.length;for(let t=0;t<s.length;t++)e[t]=s[t]}}export{f as StaticMeshes};

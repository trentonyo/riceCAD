import"../../core/tracing.js";import{math as e}from"../../core/math/math.js";import{Vec3 as t}from"../../core/math/vec3.js";import{Vec4 as s}from"../../core/math/vec4.js";import{Mat4 as a}from"../../core/math/mat4.js";import{Color as r}from"../../core/math/color.js";import{BoundingBox as o}from"../../core/shape/bounding-box.js";import{SHADOW_VSM8 as i,SHADOW_VSM32 as n,SHADOW_PCF5 as d,SHADOW_PCF3 as l,LIGHTTYPE_SPOT as h,LIGHTTYPE_OMNI as c,LIGHTTYPE_DIRECTIONAL as f,SORTKEY_DEPTH as p,SHADOWUPDATE_NONE as u,SHADOWUPDATE_THISFRAME as m,BLUR_GAUSSIAN as w,SHADER_SHADOW as g}from"../constants.js";import{LightCamera as S}from"./light-camera.js";import{FUNC_LESSEQUAL as C}from"../../platform/graphics/constants.js";import{drawQuadWithShader as y}from"../../platform/graphics/simple-post-effect.js";import{shaderChunks as b}from"../shader-lib/chunks/chunks.js";import{createShaderFromCode as _}from"../shader-lib/utils.js";import{ShadowMap as V}from"./shadow-map.js";import{ShadowMapCache as v}from"./shadow-map-cache.js";import{ShaderPass as x}from"../shader-pass.js";const M=[new t,new t,new t,new t,new t,new t,new t,new t],R={min:0,max:0};function D(e,t,s){M[0].x=M[1].x=M[2].x=M[3].x=t.x,M[1].y=M[3].y=M[7].y=M[5].y=t.y,M[2].z=M[3].z=M[6].z=M[7].z=t.z,M[4].x=M[5].x=M[6].x=M[7].x=s.x,M[0].y=M[2].y=M[4].y=M[6].y=s.y,M[0].z=M[1].z=M[4].z=M[5].z=s.z;let a=9999999999,r=-9999999999;for(let t=0;t<8;++t){e.transformPoint(M[t],M[t]);const s=M[t].z;s<a&&(a=s),s>r&&(r=s)}return R.min=a,R.max=r,R}function P(e,t){return Math.exp(-e*e/(2*t*t))}const B=new o,T=new a,O=new a,I=new Float32Array(2),j=new s(1,1,0,0),z={r:1,g:2,b:3,a:4},A=new t,E=new a;function L(e){const t=e.material,s=e.skinInstance?10:0;let a=0;if(t.opacityMap){const e=t.opacityMapChannel;e&&(a=z[e])}return s+a}class k{constructor(e,t){this.device=e.device,this.forwardRenderer=e,this.lightTextureAtlas=t;const s=this.device.scope;this.polygonOffsetId=s.resolve("polygonOffset"),this.polygonOffset=new Float32Array(2),this.sourceId=s.resolve("source"),this.pixelOffsetId=s.resolve("pixelOffset"),this.weightId=s.resolve("weight[0]"),this.blurVsmShaderCode=[b.blurVSMPS,"#define GAUSS\n"+b.blurVSMPS];const a="#define PACKED\n";this.blurPackedVsmShaderCode=[a+this.blurVsmShaderCode[0],a+this.blurVsmShaderCode[1]],this.blurVsmShader=[{},{}],this.blurPackedVsmShader=[{},{}],this.blurVsmWeights={},this.shadowMapLightRadiusId=s.resolve("light_radius"),this.shadowMapCache=new v}destroy(){this.shadowMapCache.destroy(),this.shadowMapCache=null}static createShadowCamera(e,t,s,a){const o=S.create("ShadowCamera",s,a);return o.clearColor=t>=i&&t<=n?new r(0,0,0,0):new r(1,1,1,1),o.clearDepthBuffer=!0,o.clearStencilBuffer=!1,o}static setShadowCameraSettings(e,t,s,a,r){let o=s===d||s===l&&t.webgl2;a!==c||r||(o=!1),e.clearColorBuffer=!o}cullShadowCasters(e,t,s){let a=0;const r=e.length;for(let o=0;o<r;o++){const r=e[o];r.cull&&!r._isVisible(s)||(r.visibleThisFrame=!0,t[a]=r,a++)}t.length=a,t.sort(this.forwardRenderer.depthSortCompare)}cullLocal(t,s){const a=this.forwardRenderer.scene.clusteredLightingEnabled;t.visibleThisFrame=!0,a||t._shadowMap||(t._shadowMap=V.create(this.device,t));const r=t._type,o=r===h?1:6;for(let i=0;i<o;i++){const o=t.getRenderData(null,i),n=o.shadowCamera;n.nearClip=t.attenuationEnd/1e3,n.farClip=t.attenuationEnd;const d=n._node,l=t._node;if(d.setPosition(l.getPosition()),r===h)n.fov=2*t._outerConeAngle,d.setRotation(l.getRotation()),d.rotateLocal(-90,0,0);else if(r===c)if(a){const s=2/(this.lightTextureAtlas.shadowAtlasResolution*t.atlasViewport.z/3)*this.lightTextureAtlas.shadowEdgePixels;n.fov=Math.atan(1+s)*e.RAD_TO_DEG*2}else n.fov=90;this.forwardRenderer.updateCameraFrustum(n),this.cullShadowCasters(s,o.visibleCasters,n)}}generateSplitDistances(t,s,a){t._shadowCascadeDistances.fill(a);for(let r=1;r<t.numCascades;r++){const o=r/t.numCascades,i=s+(a-s)*o,n=s*(a/s)**o,d=e.lerp(i,n,t.cascadeDistribution);t._shadowCascadeDistances[r-1]=d}}cullDirectional(e,t,s){e.visibleThisFrame=!0,e._shadowMap||(e._shadowMap=V.create(this.device,e));const a=s._nearClip;this.generateSplitDistances(e,a,e.shadowDistance);for(let r=0;r<e.numCascades;r++){const o=e.getRenderData(s,r),i=o.shadowCamera;i.renderTarget=e._shadowMap.renderTargets[0],o.shadowViewport.copy(e.cascades[r]),o.shadowScissor.copy(e.cascades[r]);const n=i._node,d=e._node;n.setPosition(d.getPosition()),n.setRotation(d.getRotation()),n.rotateLocal(-90,0,0);const l=0===r?a:e._shadowCascadeDistances[r-1],h=e._shadowCascadeDistances[r],c=s.getFrustumCorners(l,h);A.set(0,0,0);const f=s.node.getWorldTransform();for(let e=0;e<8;e++)f.transformPoint(c[e],c[e]),A.add(c[e]);A.mulScalar(1/8);let p=0;for(let e=0;e<8;e++){const t=c[e].sub(A).length();t>p&&(p=t)}const u=n.right,m=n.up,w=n.forward,g=.25*e._shadowResolution/p,S=Math.ceil(A.dot(m)*g)/g,C=Math.ceil(A.dot(u)*g)/g,y=m.mulScalar(S),b=u.mulScalar(C),_=A.dot(w),V=w.mulScalar(_);A.add2(y,b).add(V),n.setPosition(A),n.translateLocal(0,0,1e6),i.nearClip=0,i.farClip=2e6,i.orthoHeight=p,this.forwardRenderer.updateCameraFrustum(i),this.cullShadowCasters(t,o.visibleCasters,i);let v=!0;const x=o.visibleCasters;for(let e=0;e<x.length;e++){const t=x[e];v?(v=!1,B.copy(t.aabb)):B.add(t.aabb)}T.copy(n.getWorldTransform()).invert();const M=D(T,B.getMin(),B.getMax());n.translateLocal(0,0,M.max+.1),i.farClip=M.max-M.min+.2}}setupRenderState(e,t){const s=this.forwardRenderer.scene.clusteredLightingEnabled;e.webgl2?t._type!==c||s?(e.setDepthBias(!0),e.setDepthBiasValues(-1e3*t.shadowBias,-1e3*t.shadowBias)):e.setDepthBias(!1):e.extStandardDerivatives&&(t._type===c?(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset)):(this.polygonOffset[0]=-1e3*t.shadowBias,this.polygonOffset[1]=-1e3*t.shadowBias,this.polygonOffsetId.setValue(this.polygonOffset))),e.setBlending(!1),e.setDepthWrite(!0),e.setDepthTest(!0),e.setDepthFunc(C);(s?t._isPcf&&e.webgl2:t._isPcf&&e.webgl2&&t._type!==c)?e.setColorWrite(!1,!1,!1,!1):e.setColorWrite(!0,!0,!0,!0)}restoreRenderState(e){e.webgl2?e.setDepthBias(!1):e.extStandardDerivatives&&(this.polygonOffset[0]=0,this.polygonOffset[1]=0,this.polygonOffsetId.setValue(this.polygonOffset))}dispatchUniforms(e,s,a,r){const o=s._node;e._type!==f&&(this.forwardRenderer.dispatchViewPos(o.getPosition()),this.shadowMapLightRadiusId.setValue(e.attenuationEnd)),T.setTRS(o.getPosition(),o.getRotation(),t.ONE).invert(),O.mul2(s.projectionMatrix,T);const i=a.shadowViewport;s.rect=i,s.scissorRect=a.shadowScissor,E.setViewport(i.x,i.y,i.z,i.w),a.shadowMatrix.mul2(E,O),e._type===f&&e._shadowMatrixPalette.set(a.shadowMatrix.data,16*r)}submitCasters(e,t){const s=this.device,a=this.forwardRenderer,r=a.scene,o=1<<g,i=x.getShadow(t._type,t._shadowType),n=e.length;for(let t=0;t<n;t++){const n=e[t],d=n.mesh;n.ensureMaterial(s);const l=n.material;a.setBaseConstants(s,l),a.setSkinning(s,n,l),l.dirty&&(l.updateUniforms(s,r),l.dirty=!1),l.chunks&&(a.setCullMode(!0,!1,n),l.setParameters(s),n.setParameters(s,o));let h=n._shader[i];h||(n.updatePassShader(r,i),h=n._shader[i],n._key[p]=L(n)),!h.failed&&s.setShader(h),a.setVertexBuffers(s,d),a.setMorphing(s,n.morphInstance);const c=n.renderStyle;s.setIndexBuffer(d.indexBuffer[c]),a.drawInstance(s,n,d,c),a._shadowDrawCalls++}}render(e,t){if(e.enabled&&e.castShadows&&e.shadowUpdateMode!==u&&e.visibleThisFrame){const s=this.device;e.shadowUpdateMode===m&&(e.shadowUpdateMode=u);const a=e._type,r=e._shadowType,o=e.numShadowFaces,i=this.forwardRenderer;i._shadowMapUpdates+=o;const n=i.scene.clusteredLightingEnabled;this.setupRenderState(s,e);for(let d=0;d<o;d++){const o=e.getRenderData(a===f?t:null,d),l=o.shadowCamera;k.setShadowCameraSettings(l,s,r,a,n);const h=a===f?0:d;l.renderTarget=e._shadowMap.renderTargets[h],this.dispatchUniforms(e,l,o,d),i.setCamera(l,l.renderTarget,!0),this.submitCasters(o.visibleCasters,e)}if(e._isVsm&&e._vsmBlurSize>1){this.forwardRenderer.scene.clusteredLightingEnabled&&a!==f||this.applyVsmBlur(e,t)}this.restoreRenderState(s)}}getVsmBlurShader(e,t,s){let a=(e?this.blurPackedVsmShader:this.blurVsmShader)[t][s];if(!a){this.blurVsmWeights[s]=function(e){e>25&&(e=25);const t=(e-1)/6,s=.5*(e-1),a=new Array(e);let r=0;for(let o=0;o<e;++o)a[o]=P(o-s,t),r+=a[o];for(let t=0;t<e;++t)a[t]/=r;return a}(s);const r=b.fullscreenQuadVS;let o="#define SAMPLES "+s+"\n";o+=e?this.blurPackedVsmShaderCode[t]:this.blurVsmShaderCode[t];const i="blurVsm"+t+s+e;a=_(this.device,r,o,i),e?this.blurPackedVsmShader[t][s]=a:this.blurVsmShader[t][s]=a}return a}applyVsmBlur(e,t){const s=this.device,a=e.getRenderData(e._type===f?t:null,0).shadowCamera.renderTarget,r=this.shadowMapCache.get(s,e),o=r.renderTargets[0],n=e._shadowType===i,d=e.vsmBlurMode,l=e._vsmBlurSize,h=this.getVsmBlurShader(n,d,l);j.z=e._shadowResolution-2,j.w=j.z,this.sourceId.setValue(a.colorBuffer),I[0]=1/e._shadowResolution,I[1]=0,this.pixelOffsetId.setValue(I),d===w&&this.weightId.setValue(this.blurVsmWeights[l]),y(s,o,h,null,j),this.sourceId.setValue(o.colorBuffer),I[1]=I[0],I[0]=0,this.pixelOffsetId.setValue(I),y(s,a,h,null,j),this.shadowMapCache.add(e,r)}}export{k as ShadowRenderer};

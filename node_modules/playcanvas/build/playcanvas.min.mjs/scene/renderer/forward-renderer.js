import"../../core/time.js";import"../../core/tracing.js";import{Mat3 as e}from"../../core/math/mat3.js";import{Mat4 as t}from"../../core/math/mat4.js";import{Vec3 as s}from"../../core/math/vec3.js";import{Color as i}from"../../core/math/color.js";import{BoundingSphere as a}from"../../core/shape/bounding-sphere.js";import{UNIFORMTYPE_MAT4 as r,UNIFORM_BUFFER_DEFAULT_SLOT_NAME as o,SHADERSTAGE_VERTEX as n,SHADERSTAGE_FRAGMENT as l,TEXTUREDIMENSION_2D as h,SAMPLETYPE_UNFILTERABLE_FLOAT as d,BINDGROUP_VIEW as c,CLEARFLAG_COLOR as u,CLEARFLAG_DEPTH as p,CLEARFLAG_STENCIL as g,CULLFACE_NONE as m,CULLFACE_FRONTANDBACK as f,CULLFACE_FRONT as w,CULLFACE_BACK as _,FUNC_ALWAYS as I,STENCILOP_KEEP as C,BINDGROUP_MESH as v,SEMANTIC_ATTR as x}from"../../platform/graphics/constants.js";import{UniformBuffer as S}from"../../platform/graphics/uniform-buffer.js";import{UniformBufferFormat as M,UniformFormat as y}from"../../platform/graphics/uniform-buffer-format.js";import{BindGroupFormat as P,BindBufferFormat as V,BindTextureFormat as b}from"../../platform/graphics/bind-group-format.js";import{BindGroup as k}from"../../platform/graphics/bind-group.js";import{RenderPass as T}from"../../platform/graphics/render-pass.js";import{SORTKEY_FORWARD as L,SORTKEY_DEPTH as D,VIEW_CENTER as R,PROJECTION_ORTHOGRAPHIC as F,LIGHTSHAPE_PUNCTUAL as B,LIGHTTYPE_OMNI as j,LIGHTTYPE_SPOT as z,LIGHTTYPE_DIRECTIONAL as O,SHADOWUPDATE_NONE as A,SHADOWUPDATE_THISFRAME as U,FOG_NONE as W,FOG_LINEAR as E,LAYERID_DEPTH as H,COMPUPDATED_LIGHTS as q}from"../constants.js";import{Material as G}from"../materials/material.js";import{LightTextureAtlas as N}from"../lighting/light-texture-atlas.js";import{ShadowRenderer as Y}from"./shadow-renderer.js";import{StaticMeshes as X}from"./static-meshes.js";import{CookieRenderer as Z}from"./cookie-renderer.js";import{LightCamera as J}from"./light-camera.js";import"../lighting/world-clusters-debug.js";const K=new t,Q=new t,$=new e,ee=new t;let te;const se=(new t).setScale(1,-1,1),ie=new t,ae=new t,re=new s,oe=new s,ne=new s,le=new i(254/255,254/255,254/255,254/255),he=new a,de=[0,0,0,0];let ce,ue,pe,ge,me,fe=0;const we={drawCalls:[],isNewMaterial:[],lightMaskChanged:[]},_e=new Set;class Ie{constructor(e){this.clustersDebugRendered=!1,this.device=e;const t=this.device;this.scene=null,this._shadowDrawCalls=0,this._forwardDrawCalls=0,this._skinDrawCalls=0,this._numDrawCallsCulled=0,this._instancedDrawCalls=0,this._camerasRendered=0,this._materialSwitches=0,this._shadowMapUpdates=0,this._shadowMapTime=0,this._depthMapTime=0,this._forwardTime=0,this._cullTime=0,this._sortTime=0,this._skinTime=0,this._morphTime=0,this._layerCompositionUpdateTime=0,this._lightClustersTime=0,this._lightClusters=0,this.lightTextureAtlas=new N(t),this._shadowRenderer=new Y(this,this.lightTextureAtlas),this._cookieRenderer=new Z(t,this.lightTextureAtlas);const s=t.scope;this.projId=s.resolve("matrix_projection"),this.projSkyboxId=s.resolve("matrix_projectionSkybox"),this.viewId=s.resolve("matrix_view"),this.viewId3=s.resolve("matrix_view3"),this.viewInvId=s.resolve("matrix_viewInverse"),this.viewProjId=s.resolve("matrix_viewProjection"),this.flipYId=s.resolve("projectionFlipY"),this.viewPos=new Float32Array(3),this.viewPosId=s.resolve("view_position"),this.nearClipId=s.resolve("camera_near"),this.farClipId=s.resolve("camera_far"),this.cameraParamsId=s.resolve("camera_params"),this.tbnBasis=s.resolve("tbnBasis"),this.fogColorId=s.resolve("fog_color"),this.fogStartId=s.resolve("fog_start"),this.fogEndId=s.resolve("fog_end"),this.fogDensityId=s.resolve("fog_density"),this.modelMatrixId=s.resolve("matrix_model"),this.normalMatrixId=s.resolve("matrix_normal"),this.poseMatrixId=s.resolve("matrix_pose[0]"),this.boneTextureId=s.resolve("texture_poseMap"),this.boneTextureSizeId=s.resolve("texture_poseMapSize"),this.morphWeightsA=s.resolve("morph_weights_a"),this.morphWeightsB=s.resolve("morph_weights_b"),this.morphPositionTex=s.resolve("morphPositionTex"),this.morphNormalTex=s.resolve("morphNormalTex"),this.morphTexParams=s.resolve("morph_tex_params"),this.alphaTestId=s.resolve("alpha_ref"),this.opacityMapId=s.resolve("texture_opacityMap"),this.ambientId=s.resolve("light_globalAmbient"),this.exposureId=s.resolve("exposure"),this.skyboxIntensityId=s.resolve("skyboxIntensity"),this.cubeMapRotationMatrixId=s.resolve("cubeMapRotationMatrix"),this.lightColorId=[],this.lightDir=[],this.lightDirId=[],this.lightShadowMapId=[],this.lightShadowMatrixId=[],this.lightShadowParamsId=[],this.lightShadowIntensity=[],this.lightRadiusId=[],this.lightPos=[],this.lightPosId=[],this.lightWidth=[],this.lightWidthId=[],this.lightHeight=[],this.lightHeightId=[],this.lightInAngleId=[],this.lightOutAngleId=[],this.lightCookieId=[],this.lightCookieIntId=[],this.lightCookieMatrixId=[],this.lightCookieOffsetId=[],this.shadowMatrixPaletteId=[],this.shadowCascadeDistancesId=[],this.shadowCascadeCountId=[],this.screenSizeId=s.resolve("uScreenSize"),this._screenSize=new Float32Array(4),this.twoSidedLightingNegScaleFactorId=s.resolve("twoSidedLightingNegScaleFactor"),this.fogColor=new Float32Array(3),this.ambientColor=new Float32Array(3),this.cameraParams=new Float32Array(4),this.viewUniformFormat=null,this.viewBindGroupFormat=null}destroy(){this._shadowRenderer.destroy(),this._shadowRenderer=null,this._cookieRenderer.destroy(),this._cookieRenderer=null,this.lightTextureAtlas.destroy(),this.lightTextureAtlas=null}sortCompare(e,t){if(e.layer===t.layer){if(e.drawOrder&&t.drawOrder)return e.drawOrder-t.drawOrder;if(e.zdist&&t.zdist)return t.zdist-e.zdist;if(e.zdist2&&t.zdist2)return e.zdist2-t.zdist2}return t._key[L]-e._key[L]}sortCompareMesh(e,t){if(e.layer===t.layer){if(e.drawOrder&&t.drawOrder)return e.drawOrder-t.drawOrder;if(e.zdist&&t.zdist)return t.zdist-e.zdist}return ge=e._key[L],me=t._key[L],ge===me&&e.mesh&&t.mesh?t.mesh.id-e.mesh.id:me-ge}depthSortCompare(e,t){return ge=e._key[D],me=t._key[D],ge===me&&e.mesh&&t.mesh?t.mesh.id-e.mesh.id:me-ge}updateCameraFrustum(e){if(e.xr&&e.xr.views.length){const t=e.xr.views[0];return ee.mul2(t.projMat,t.viewOffMat),void e.frustum.setFromMat4(ee)}if(te=e.projectionMatrix,e.calculateProjection&&e.calculateProjection(te,R),e.calculateTransform)e.calculateTransform(K,R);else{const t=e._node.getPosition(),i=e._node.getRotation();K.setTRS(t,i,s.ONE),this.viewInvId.setValue(K.data)}Q.copy(K).invert(),ee.mul2(te,Q),e.frustum.setFromMat4(ee)}initViewBindGroupFormat(){this.device.supportsUniformBuffers&&!this.viewUniformFormat&&(this.viewUniformFormat=new M(this.device,[new y("matrix_viewProjection",r)]),this.viewBindGroupFormat=new P(this.device,[new V(o,n|l)],[new b("lightsTextureFloat",l,h,d)]))}setCameraUniforms(e,t,i){let a,r=1;if(e.xr&&e.xr.session){const t=e._node.parent;t&&(a=t.getWorldTransform());const s=e.xr.views;r=s.length;for(let i=0;i<r;i++){const r=s[i];t?(r.viewInvOffMat.mul2(a,r.viewInvMat),r.viewOffMat.copy(r.viewInvOffMat).invert()):(r.viewInvOffMat.copy(r.viewInvMat),r.viewOffMat.copy(r.viewMat)),r.viewMat3.setFromMat4(r.viewOffMat),r.projViewOffMat.mul2(r.projMat,r.viewOffMat),r.position[0]=r.viewInvOffMat.data[12],r.position[1]=r.viewInvOffMat.data[13],r.position[2]=r.viewInvOffMat.data[14],e.frustum.setFromMat4(r.projViewOffMat)}}else{if(te=e.projectionMatrix,e.calculateProjection&&e.calculateProjection(te,R),this.projId.setValue(te.data),this.projSkyboxId.setValue(e.getProjectionMatrixSkybox().data),e.calculateTransform)e.calculateTransform(K,R);else{const t=e._node.getPosition(),i=e._node.getRotation();K.setTRS(t,i,s.ONE)}this.viewInvId.setValue(K.data),Q.copy(K).invert(),this.viewId.setValue(Q.data),$.setFromMat4(Q),this.viewId3.setValue($.data),ee.mul2(te,Q),t&&t.flipY?(ie.mul2(se,ee),ae.mul2(se,e.getProjectionMatrixSkybox()),this.viewProjId.setValue(ie.data),this.projSkyboxId.setValue(ae.data)):(this.viewProjId.setValue(ee.data),this.projSkyboxId.setValue(e.getProjectionMatrixSkybox().data)),this.flipYId.setValue(null!=t&&t.flipY?-1:1),this.dispatchViewPos(e._node.getPosition()),e.frustum.setFromMat4(ee)}this.tbnBasis.setValue(t&&t.flipY?-1:1),this.nearClipId.setValue(e._nearClip),this.farClipId.setValue(e._farClip),this.scene.physicalUnits?this.exposureId.setValue(e.getExposure()):this.exposureId.setValue(this.scene.exposure);const o=e._nearClip,n=e._farClip;this.cameraParams[0]=1/n,this.cameraParams[1]=n,this.cameraParams[2]=o,this.cameraParams[3]=e.projection===F?1:0,this.cameraParamsId.setValue(this.cameraParams),this.device.supportsUniformBuffers&&this.setupViewUniformBuffers(i,r)}setCamera(e,t,s,i=null){this.setCameraUniforms(e,t,i),this.clearView(e,t,s,!1)}setupViewUniformBuffers(e,t){if(e){const s=this.device;for(;e.viewBindGroups.length<t;){const t=new S(s,this.viewUniformFormat),i=new k(s,this.viewBindGroupFormat,t);e.viewBindGroups.push(i)}const i=e.viewBindGroups[0];i.defaultUniformBuffer.update(),i.update(),s.setBindGroup(c,i)}}setupViewport(e,t){const s=this.device,i=t?t.width:s.width,a=t?t.height:s.height,r=e.rect;let o=Math.floor(r.x*i),n=Math.floor(r.y*a),l=Math.floor(r.z*i),h=Math.floor(r.w*a);if(s.setViewport(o,n,l,h),e._scissorRectClear){const t=e.scissorRect;o=Math.floor(t.x*i),n=Math.floor(t.y*a),l=Math.floor(t.z*i),h=Math.floor(t.w*a)}s.setScissor(o,n,l,h)}clear(e,t){this.device.clear({color:[t._clearColor.r,t._clearColor.g,t._clearColor.b,t._clearColor.a],depth:t._clearDepth,stencil:t._clearStencil,flags:(e.clearColor?u:0)|(e.clearDepth?p:0)|(e.clearStencil?g:0)})}clearView(e,t,s,i){const a=this.device;if(a.setRenderTarget(t),a.updateBegin(),i&&(a.setColorWrite(!0,!0,!0,!0),a.setDepthWrite(!0)),this.setupViewport(e,t),s){const t=e._clearOptions;a.clear(t||{color:[e._clearColor.r,e._clearColor.g,e._clearColor.b,e._clearColor.a],depth:e._clearDepth,flags:(e._clearColorBuffer?u:0)|(e._clearDepthBuffer?p:0)|(e._clearStencilBuffer?g:0),stencil:e._clearStencil})}}dispatchGlobalLights(e){if(this.ambientColor[0]=e.ambientLight.r,this.ambientColor[1]=e.ambientLight.g,this.ambientColor[2]=e.ambientLight.b,e.gammaCorrection)for(let e=0;e<3;e++)this.ambientColor[e]=Math.pow(this.ambientColor[e],2.2);if(e.physicalUnits)for(let t=0;t<3;t++)this.ambientColor[t]*=e.ambientLuminance;this.ambientId.setValue(this.ambientColor),this.skyboxIntensityId.setValue(e.physicalUnits?e.skyboxLuminance:e.skyboxIntensity),this.cubeMapRotationMatrixId.setValue(e._skyboxRotationMat3.data)}_resolveLight(e,t){const s="light"+t;this.lightColorId[t]=e.resolve(s+"_color"),this.lightDir[t]=new Float32Array(3),this.lightDirId[t]=e.resolve(s+"_direction"),this.lightShadowMapId[t]=e.resolve(s+"_shadowMap"),this.lightShadowMatrixId[t]=e.resolve(s+"_shadowMatrix"),this.lightShadowParamsId[t]=e.resolve(s+"_shadowParams"),this.lightShadowIntensity[t]=e.resolve(s+"_shadowIntensity"),this.lightRadiusId[t]=e.resolve(s+"_radius"),this.lightPos[t]=new Float32Array(3),this.lightPosId[t]=e.resolve(s+"_position"),this.lightWidth[t]=new Float32Array(3),this.lightWidthId[t]=e.resolve(s+"_halfWidth"),this.lightHeight[t]=new Float32Array(3),this.lightHeightId[t]=e.resolve(s+"_halfHeight"),this.lightInAngleId[t]=e.resolve(s+"_innerConeAngle"),this.lightOutAngleId[t]=e.resolve(s+"_outerConeAngle"),this.lightCookieId[t]=e.resolve(s+"_cookie"),this.lightCookieIntId[t]=e.resolve(s+"_cookieIntensity"),this.lightCookieMatrixId[t]=e.resolve(s+"_cookieMatrix"),this.lightCookieOffsetId[t]=e.resolve(s+"_cookieOffset"),this.shadowMatrixPaletteId[t]=e.resolve(s+"_shadowMatrixPalette[0]"),this.shadowCascadeDistancesId[t]=e.resolve(s+"_shadowCascadeDistances[0]"),this.shadowCascadeCountId[t]=e.resolve(s+"_shadowCascadeCount")}setLTCDirectionalLight(e,t,i,a,r){this.lightPos[t][0]=a.x-i.x*r,this.lightPos[t][1]=a.y-i.y*r,this.lightPos[t][2]=a.z-i.z*r,this.lightPosId[t].setValue(this.lightPos[t]);const o=e.transformVector(new s(-.5,0,0));this.lightWidth[t][0]=o.x*r,this.lightWidth[t][1]=o.y*r,this.lightWidth[t][2]=o.z*r,this.lightWidthId[t].setValue(this.lightWidth[t]);const n=e.transformVector(new s(0,0,.5));this.lightHeight[t][0]=n.x*r,this.lightHeight[t][1]=n.y*r,this.lightHeight[t][2]=n.z*r,this.lightHeightId[t].setValue(this.lightHeight[t])}dispatchDirectLights(e,t,s,i){let a=0;const r=this.device.scope;for(let o=0;o<e.length;o++){if(!(e[o].mask&s))continue;const n=e[o],l=n._node.getWorldTransform();if(this.lightColorId[a]||this._resolveLight(r,a),this.lightColorId[a].setValue(t.gammaCorrection?n._linearFinalColor:n._finalColor),l.getY(n._direction).mulScalar(-1),n._direction.normalize(),this.lightDir[a][0]=n._direction.x,this.lightDir[a][1]=n._direction.y,this.lightDir[a][2]=n._direction.z,this.lightDirId[a].setValue(this.lightDir[a]),n.shape!==B&&this.setLTCDirectionalLight(l,a,n._direction,i._node.getPosition(),i.farClip),n.castShadows){const e=n.getRenderData(i,0),t=n._getUniformBiasValues(e);this.lightShadowMapId[a].setValue(e.shadowBuffer),this.lightShadowMatrixId[a].setValue(e.shadowMatrix.data),this.shadowMatrixPaletteId[a].setValue(n._shadowMatrixPalette),this.shadowCascadeDistancesId[a].setValue(n._shadowCascadeDistances),this.shadowCascadeCountId[a].setValue(n.numCascades),this.lightShadowIntensity[a].setValue(n.shadowIntensity);const s=n._shadowRenderParams;s.length=3,s[0]=n._shadowResolution,s[1]=t.normalBias,s[2]=t.bias,this.lightShadowParamsId[a].setValue(s)}a++}return a}setLTCPositionalLight(e,t){const i=e.transformVector(new s(-.5,0,0));this.lightWidth[t][0]=i.x,this.lightWidth[t][1]=i.y,this.lightWidth[t][2]=i.z,this.lightWidthId[t].setValue(this.lightWidth[t]);const a=e.transformVector(new s(0,0,.5));this.lightHeight[t][0]=a.x,this.lightHeight[t][1]=a.y,this.lightHeight[t][2]=a.z,this.lightHeightId[t].setValue(this.lightHeight[t])}dispatchOmniLight(e,t,s,i){const a=s._node.getWorldTransform();if(this.lightColorId[i]||this._resolveLight(t,i),this.lightRadiusId[i].setValue(s.attenuationEnd),this.lightColorId[i].setValue(e.gammaCorrection?s._linearFinalColor:s._finalColor),a.getTranslation(s._position),this.lightPos[i][0]=s._position.x,this.lightPos[i][1]=s._position.y,this.lightPos[i][2]=s._position.z,this.lightPosId[i].setValue(this.lightPos[i]),s.shape!==B&&this.setLTCPositionalLight(a,i),s.castShadows){const e=s.getRenderData(null,0);this.lightShadowMapId[i].setValue(e.shadowBuffer);const t=s._getUniformBiasValues(e),a=s._shadowRenderParams;a.length=4,a[0]=s._shadowResolution,a[1]=t.normalBias,a[2]=t.bias,a[3]=1/s.attenuationEnd,this.lightShadowParamsId[i].setValue(a),this.lightShadowIntensity[i].setValue(s.shadowIntensity)}s._cookie&&(this.lightCookieId[i].setValue(s._cookie),this.lightShadowMatrixId[i].setValue(a.data),this.lightCookieIntId[i].setValue(s.cookieIntensity))}dispatchSpotLight(e,t,s,i){const a=s._node.getWorldTransform();if(this.lightColorId[i]||this._resolveLight(t,i),this.lightInAngleId[i].setValue(s._innerConeAngleCos),this.lightOutAngleId[i].setValue(s._outerConeAngleCos),this.lightRadiusId[i].setValue(s.attenuationEnd),this.lightColorId[i].setValue(e.gammaCorrection?s._linearFinalColor:s._finalColor),a.getTranslation(s._position),this.lightPos[i][0]=s._position.x,this.lightPos[i][1]=s._position.y,this.lightPos[i][2]=s._position.z,this.lightPosId[i].setValue(this.lightPos[i]),s.shape!==B&&this.setLTCPositionalLight(a,i),a.getY(s._direction).mulScalar(-1),s._direction.normalize(),this.lightDir[i][0]=s._direction.x,this.lightDir[i][1]=s._direction.y,this.lightDir[i][2]=s._direction.z,this.lightDirId[i].setValue(this.lightDir[i]),s.castShadows){const e=s.getRenderData(null,0);this.lightShadowMapId[i].setValue(e.shadowBuffer),this.lightShadowMatrixId[i].setValue(e.shadowMatrix.data);const t=s._getUniformBiasValues(e),a=s._shadowRenderParams;a.length=4,a[0]=s._shadowResolution,a[1]=t.normalBias,a[2]=t.bias,a[3]=1/s.attenuationEnd,this.lightShadowParamsId[i].setValue(a),this.lightShadowIntensity[i].setValue(s.shadowIntensity)}if(s._cookie){if(!s.castShadows){const e=J.evalSpotCookieMatrix(s);this.lightShadowMatrixId[i].setValue(e.data)}this.lightCookieId[i].setValue(s._cookie),this.lightCookieIntId[i].setValue(s.cookieIntensity),s._cookieTransform&&(s._cookieTransformUniform[0]=s._cookieTransform.x,s._cookieTransformUniform[1]=s._cookieTransform.y,s._cookieTransformUniform[2]=s._cookieTransform.z,s._cookieTransformUniform[3]=s._cookieTransform.w,this.lightCookieMatrixId[i].setValue(s._cookieTransformUniform),s._cookieOffsetUniform[0]=s._cookieOffset.x,s._cookieOffsetUniform[1]=s._cookieOffset.y,this.lightCookieOffsetId[i].setValue(s._cookieOffsetUniform))}}dispatchLocalLights(e,t,s,i,a){let r=i;const o=this.device.scope,n=e[j],l=n.length;for(let e=0;e<l;e++){const i=n[e];i.mask&s&&(i.isStatic||(this.dispatchOmniLight(t,o,i,r),r++))}let h=0;if(a){let e=a[h];for(;e&&e._type===j;)this.dispatchOmniLight(t,o,e,r),r++,h++,e=a[h]}const d=e[z],c=d.length;for(let e=0;e<c;e++){const i=d[e];i.mask&s&&(i.isStatic||(this.dispatchSpotLight(t,o,i,r),r++))}if(a){let e=a[h];for(;e&&e._type===z;)this.dispatchSpotLight(t,o,e,r),r++,h++,e=a[h]}}cull(e,t,s){let i=0;const a=t.length,r=e.cullingMask||4294967295;if(!e.frustumCulling){for(let e=0;e<a;e++){const a=t[e];(a.visible||a.command)&&(a.mask&&0==(a.mask&r)||(s[i]=a,i++,a.visibleThisFrame=!0))}return i}for(let o=0;o<a;o++){const a=t[o];if(a.command)s[i]=a,i++,a.visibleThisFrame=!0;else{if(!a.visible)continue;let t=!0;if(a.mask&&0==(a.mask&r))continue;a.cull&&(t=a._isVisible(e)),t&&(s[i]=a,i++,a.visibleThisFrame=!0)}}return i}cullLights(e,t){const s=this.scene.clusteredLightingEnabled,i=this.scene.physicalUnits;for(let a=0;a<t.length;a++){const r=t[a];if(r.enabled)if(r._type!==O)if(r.getBoundingSphere(he),e.frustum.containsSphere(he)){r.visibleThisFrame=!0,r.usePhysicalUnits=i;const t=e.getScreenSize(he);r.maxScreenSize=Math.max(r.maxScreenSize,t)}else s||r.castShadows&&!r.shadowMap&&(r.visibleThisFrame=!0);else r.usePhysicalUnits=this.scene.physicalUnits}}updateCpuSkinMatrices(e){fe++;const t=e.length;if(0!==t)for(let s=0;s<t;s++){const t=e[s].skinInstance;t&&(t.updateMatrices(e[s].node,fe),t._dirty=!0)}}updateGpuSkinMatrices(e){const t=e.length;for(let s=0;s<t;s++){if(!e[s].visibleThisFrame)continue;const t=e[s].skinInstance;t&&t._dirty&&(t.updateMatrixPalette(e[s].node,fe),t._dirty=!1)}}updateMorphing(e){const t=e.length;for(let s=0;s<t;s++){const t=e[s].morphInstance;t&&t._dirty&&e[s].visibleThisFrame&&t.update()}}setBaseConstants(e,t){e.setCullMode(t.cull),t.opacityMap&&(this.opacityMapId.setValue(t.opacityMap),this.alphaTestId.setValue(t.alphaTest))}setSkinning(e,t,s){t.skinInstance&&(this._skinDrawCalls++,e.supportsBoneTextures?(ce=t.skinInstance.boneTexture,this.boneTextureId.setValue(ce),de[0]=ce.width,de[1]=ce.height,de[2]=1/ce.width,de[3]=1/ce.height,this.boneTextureSizeId.setValue(de)):this.poseMatrixId.setValue(t.skinInstance.matrixPalette))}drawInstance(e,t,s,i,a){ue=t.instancingData,ue?ue.count>0&&(this._instancedDrawCalls++,e.setVertexBuffer(ue.vertexBuffer),e.draw(s.primitive[i],ue.count)):(pe=t.node.worldTransform,this.modelMatrixId.setValue(pe.data),a&&this.normalMatrixId.setValue(t.node.normalMatrix.data),e.draw(s.primitive[i]))}drawInstance2(e,t,s,i){ue=t.instancingData,ue?ue.count>0&&(this._instancedDrawCalls++,e.draw(s.primitive[i],ue.count,!0)):e.draw(s.primitive[i],void 0,!0)}renderShadows(e,t){const s=this.scene.clusteredLightingEnabled;for(let i=0;i<e.length;i++){const a=e[i];if(s&&a._type!==O){if(!a.atlasViewportAllocated)continue;a.atlasSlotUpdated&&a.shadowUpdateMode===A&&(a.shadowUpdateMode=U)}this._shadowRenderer.render(a,t)}}renderCookies(e){const t=this.lightTextureAtlas.cookieRenderTarget;for(let s=0;s<e.length;s++){const i=e[s];i.atlasViewportAllocated&&(i.atlasSlotUpdated&&this._cookieRenderer.render(i,t))}}setCullMode(e,t,s){const i=s.material;let a=m;if(e){let e=1;if(i.cull>m&&i.cull<f){s.flipFaces&&(e*=-1),t&&(e*=-1);const i=s.node.worldTransform;i.getX(re),i.getY(oe),i.getZ(ne),re.cross(re,oe),re.dot(ne)<0&&(e*=-1)}a=e<0?i.cull===w?_:w:i.cull}if(this.device.setCullMode(a),a===m&&i.cull===m){const e=s.node.worldTransform;e.getX(re),e.getY(oe),e.getZ(ne),re.cross(re,oe),re.dot(ne)<0?this.twoSidedLightingNegScaleFactorId.setValue(-1):this.twoSidedLightingNegScaleFactorId.setValue(1)}}setVertexBuffers(e,t){e.setVertexBuffer(t.vertexBuffer)}setMorphing(e,t){if(t)if(t.morph.useTextureMorph)e.setVertexBuffer(t.morph.vertexBufferIds),this.morphPositionTex.setValue(t.texturePositions),this.morphNormalTex.setValue(t.textureNormals),this.morphTexParams.setValue(t._textureParams);else{for(let s=0;s<t._activeVertexBuffers.length;s++){const i=t._activeVertexBuffers[s];if(i){const t=x+(s+8);i.format.elements[0].name=t,i.format.elements[0].scopeId=e.scope.resolve(t),i.format.update(),e.setVertexBuffer(i)}}this.morphWeightsA.setValue(t._shaderMorphWeightsA),this.morphWeightsB.setValue(t._shaderMorphWeightsB)}}dispatchViewPos(e){const t=this.viewPos;t[0]=e.x,t[1]=e.y,t[2]=e.z,this.viewPosId.setValue(t)}renderForwardPrepareMaterials(e,t,s,i,a,r,o){const n=(e,t,s)=>{we.drawCalls.push(e),we.isNewMaterial.push(t),we.lightMaskChanged.push(s)};we.drawCalls.length=0,we.isNewMaterial.length=0,we.lightMaskChanged.length=0;const l=this.device,h=this.scene,d=r?r._lightHash:0;let c,u,p,g=null;for(let e=0;e<s;e++){const s=t[e];if(!a||!s.mask||a&s.mask)if(s.command)n(s,!1,!1);else{s.ensureMaterial(l);const e=s.material,t=s._shaderDefs,a=s.mask;if(e&&e===g&&t!==c&&(g=null),(s.isStatic||u)&&(g=null),e!==g&&(this._materialSwitches++,e._scene=h,e.dirty&&(e.updateUniforms(l,h),e.dirty=!1),e._dirtyBlend&&(h.layers._dirtyBlend=!0)),!s._shader[o]||s._shaderDefs!==t||s._lightHash!==d){if(s.isStatic)s.updatePassShader(h,o,s._staticLightList,i,this.viewUniformFormat,this.viewBindGroupFormat);else{const a=o+"_"+t+"_"+d;s._shader[o]=e.variants[a],s._shader[o]||(s.updatePassShader(h,o,null,i,this.viewUniformFormat,this.viewBindGroupFormat),e.variants[a]=s._shader[o])}s._lightHash=d}n(s,e!==g,!g||a!==p),g=e,c=t,p=a,u=s.isStatic}}return we}renderForwardInternal(e,t,s,i,a,r){const o=this.device,n=o.supportsUniformBuffers,l=this.scene,h=1<<i,d=t.drawCalls.length;for(let c=0;c<d;c++){const u=t.drawCalls[c];if(u.command)u.command();else{const p=t.isNewMaterial[c],g=t.lightMaskChanged[c],m=u.material;u._shaderDefs;const f=u.mask;if(p){const t=u._shader[i];if(!t.failed&&o.setShader(t),m.setParameters(o),g){const t=this.dispatchDirectLights(s[O],l,f,e);this.dispatchLocalLights(s,l,f,t,u._staticLightList)}this.alphaTestId.setValue(m.alphaTest),o.setBlending(m.blend),m.blend&&(m.separateAlphaBlend?(o.setBlendFunctionSeparate(m.blendSrc,m.blendDst,m.blendSrcAlpha,m.blendDstAlpha),o.setBlendEquationSeparate(m.blendEquation,m.blendAlphaEquation)):(o.setBlendFunction(m.blendSrc,m.blendDst),o.setBlendEquation(m.blendEquation))),o.setColorWrite(m.redWrite,m.greenWrite,m.blueWrite,m.alphaWrite),o.setDepthWrite(m.depthWrite),m.depthWrite&&!m.depthTest?(o.setDepthFunc(I),o.setDepthTest(!0)):(o.setDepthFunc(m.depthFunc),o.setDepthTest(m.depthTest)),o.setAlphaToCoverage(m.alphaToCoverage),m.depthBias||m.slopeDepthBias?(o.setDepthBias(!0),o.setDepthBiasValues(m.depthBias,m.slopeDepthBias)):o.setDepthBias(!1)}this.setCullMode(e._cullFaces,r,u);const w=u.stencilFront||m.stencilFront,_=u.stencilBack||m.stencilBack;w||_?(o.setStencilTest(!0),w===_?(o.setStencilFunc(w.func,w.ref,w.readMask),o.setStencilOperation(w.fail,w.zfail,w.zpass,w.writeMask)):(w?(o.setStencilFuncFront(w.func,w.ref,w.readMask),o.setStencilOperationFront(w.fail,w.zfail,w.zpass,w.writeMask)):(o.setStencilFuncFront(I,0,255),o.setStencilOperationFront(C,C,C,255)),_?(o.setStencilFuncBack(_.func,_.ref,_.readMask),o.setStencilOperationBack(_.fail,_.zfail,_.zpass,_.writeMask)):(o.setStencilFuncBack(I,0,255),o.setStencilOperationBack(C,C,C,255)))):o.setStencilTest(!1);const x=u.mesh;if(u.setParameters(o,h),this.setVertexBuffers(o,x),this.setMorphing(o,u.morphInstance),this.setSkinning(o,u,m),n){this.modelMatrixId.setValue(u.node.worldTransform.data),this.normalMatrixId.setValue(u.node.normalMatrix.data);const e=u.getBindGroup(o,i);e.defaultUniformBuffer.update(),e.update(),o.setBindGroup(v,e)}const S=u.renderStyle;if(o.setIndexBuffer(x.indexBuffer[S]),a&&a(u,c),e.xr&&e.xr.session&&e.xr.views.length){const t=e.xr.views;for(let e=0;e<t.length;e++){const s=t[e];o.setViewport(s.viewport.x,s.viewport.y,s.viewport.z,s.viewport.w),this.projId.setValue(s.projMat.data),this.projSkyboxId.setValue(s.projMat.data),this.viewId.setValue(s.viewOffMat.data),this.viewInvId.setValue(s.viewInvOffMat.data),this.viewId3.setValue(s.viewMat3.data),this.viewProjId.setValue(s.projViewOffMat.data),this.viewPosId.setValue(s.position),0===e?this.drawInstance(o,u,x,S,!0):this.drawInstance2(o,u,x,S),this._forwardDrawCalls++}}else this.drawInstance(o,u,x,S,!0),this._forwardDrawCalls++;c<d-1&&!t.isNewMaterial[c+1]&&m.setParameters(o,u.parameters)}}}renderForward(e,t,s,i,a,r,o,n,l){const h=this.renderForwardPrepareMaterials(e,t,s,i,r,n,a);this.renderForwardInternal(e,h,i,a,o,l),we.length=0}updateShaders(e,t){const s=e.length;for(let i=0;i<s;i++){const s=e[i].material;if(s&&!_e.has(s)&&(_e.add(s),s.getShaderVariant!==G.prototype.getShaderVariant)){if(t&&(!s.useLighting||s.emitter&&!s.emitter.lighting))continue;s.clearVariants()}}_e.clear()}beginFrame(e,t){const s=e._meshInstances,i=this.scene;if(i.updateShaders||t){const e=!i.updateShaders&&t;this.updateShaders(s,e),i.updateShaders=!1,i._shaderVersion++}this.updateCpuSkinMatrices(s);const a=s.length;for(let e=0;e<a;e++)s[e].visibleThisFrame=!1;const r=e._lights,o=r.length;for(let e=0;e<o;e++)r[e].beginFrame()}updateLayerComposition(e,t){const s=e.layerList.length;for(let t=0;t<s;t++)e.layerList[t]._postRenderCounter=0;const i=this.scene,a=i._shaderVersion;for(let t=0;t<s;t++){const s=e.layerList[t];s._shaderVersion=a,s._preRenderCalledForCameras=0,s._postRenderCalledForCameras=0;const r=e.subLayerList[t];s._postRenderCounter|=r?2:1,s._postRenderCounterMax=s._postRenderCounter;for(let e=0;e<s.cameras.length;e++)s.instances.prepare(e);s._needsStaticPrepare&&s._staticLightHash&&!this.scene.clusteredLightingEnabled&&(s._staticPrepareDone&&(X.revert(s.opaqueMeshInstances),X.revert(s.transparentMeshInstances)),X.prepare(this.device,i,s.opaqueMeshInstances,s._lights),X.prepare(this.device,i,s.transparentMeshInstances,s._lights),e._dirty=!0,i.updateShaders=!0,s._needsStaticPrepare=!1,s._staticPrepareDone=!0)}return e._update(this.device,t)}gpuUpdate(e){this.updateGpuSkinMatrices(e),this.updateMorphing(e)}setSceneConstants(){const e=this.scene;if(this.dispatchGlobalLights(e),e.fog!==W){if(this.fogColor[0]=e.fogColor.r,this.fogColor[1]=e.fogColor.g,this.fogColor[2]=e.fogColor.b,e.gammaCorrection)for(let e=0;e<3;e++)this.fogColor[e]=Math.pow(this.fogColor[e],2.2);this.fogColorId.setValue(this.fogColor),e.fog===E?(this.fogStartId.setValue(e.fogStart),this.fogEndId.setValue(e.fogEnd)):this.fogDensityId.setValue(e.fogDensity)}const t=this.device;this._screenSize[0]=t.width,this._screenSize[1]=t.height,this._screenSize[2]=1/t.width,this._screenSize[3]=1/t.height,this.screenSizeId.setValue(this._screenSize)}updateLightStats(e,t){}cullShadowmaps(e){for(let t=0;t<e._lights.length;t++){const s=e._lights[t];if(s._type!==O&&s.visibleThisFrame&&s.castShadows&&s.shadowUpdateMode!==A){const i=e._lightCompositionData[t].shadowCastersList;this._shadowRenderer.cullLocal(s,i)}}const t=e._renderActions;for(let s=0;s<t.length;s++){const i=t[s],a=i.directionalLightsIndices.length;for(let t=0;t<a;t++){const s=i.directionalLightsIndices[t],a=e._lights[s],r=e._lightCompositionData[s].shadowCastersList;this._shadowRenderer.cullDirectional(a,r,i.camera.camera)}}}cullComposition(e){const t=e._renderActions;for(let s=0;s<t.length;s++){const i=t[s],a=i.layerIndex,r=e.layerList[a];if(!r.enabled||!e.subLayerEnabled[a])continue;const o=e.subLayerList[a],n=i.cameraIndex,l=r.cameras[n];if(l){l.frameUpdate(i.renderTarget),i.firstCameraUse&&(this.updateCameraFrustum(l.camera),this._camerasRendered++),this.cullLights(l.camera,r._lights);const e=r.instances,t=o?e.visibleTransparent[n]:e.visibleOpaque[n];if(!t.done){r.onPreCull&&r.onPreCull(n);const e=o?r.transparentMeshInstances:r.opaqueMeshInstances;t.length=this.cull(l.camera,e,t.list),t.done=!0,r.onPostCull&&r.onPostCull(n)}}}this.cullShadowmaps(e)}updateLightTextureAtlas(e){this.lightTextureAtlas.update(e._splitLights[z],e._splitLights[j],this.scene.lighting)}updateClusters(e){const t=e.getEmptyWorldClusters(this.device),s=e._renderActions;for(let i=0;i<s.length;i++){const a=s[i],r=a.lightClusters;if(r&&r!==t&&!_e.has(r)){_e.add(r);const t=e.layerList[a.layerIndex];r.update(t.clusteredLightsSet,this.scene.gammaCorrection,this.scene.lighting)}}_e.clear()}buildFrameGraph(e,t){e.reset(),this.update(t);const s=this.scene.clusteredLightingEnabled;if(s){this.updateLightTextureAtlas(t);const s=new T(this.device,(()=>{this.scene.lighting.cookiesEnabled&&(this.renderCookies(t._splitLights[z]),this.renderCookies(t._splitLights[j]))}));s.requiresCubemaps=!1,e.addRenderPass(s)}const i=new T(this.device,(()=>{(!s||s&&this.scene.lighting.shadowsEnabled)&&(this.renderShadows(t._splitLights[z]),this.renderShadows(t._splitLights[j])),s&&this.updateClusters(t)}));i.requiresCubemaps=!1,e.addRenderPass(i);let a=0,r=!0,o=null;const n=t._renderActions;for(let s=a;s<n.length;s++){const i=n[s],l=t.layerList[i.layerIndex],h=l.cameras[i.cameraIndex];if(!i.isLayerEnabled(t))continue;const d=l.id===H&&(h.renderSceneColorMap||h.renderSceneDepthMap);if(i.hasDirectionalShadowLights&&h){const s=new T(this.device,(()=>{this.renderPassDirectionalShadows(i,t)}));s.requiresCubemaps=!1,e.addRenderPass(s)}r&&(r=!1,a=s,o=i.renderTarget);let c=s+1;for(;n[c]&&!n[c].isLayerEnabled(t);)c++;const u=n[c],p=!!u&&t.layerList[u.layerIndex].id===H&&(h.renderSceneColorMap||h.renderSceneDepthMap);if(!u||u.renderTarget!==o||u.hasDirectionalShadowLights||p||d){if(this.addMainRenderPass(e,t,o,a,s,d),i.triggerPostprocess&&null!=h&&h.onPostprocessing){const s=new T(this.device,(()=>{this.renderPassPostprocessing(i,t)}));s.requiresCubemaps=!1,e.addRenderPass(s)}r=!0}}}addMainRenderPass(e,t,s,i,a,r){const o={start:i,end:a},n=new T(this.device,(()=>{this.renderPassRenderActions(t,o)})),l=t._renderActions[i],h=t.layerList[l.layerIndex].cameras[l.cameraIndex],d=r&&!this.device.webgl2&&h.renderSceneDepthMap;(!r||d)&&(n.init(s),n.fullSizeClearRect=h.camera.fullSizeClearRect,d?(n.setClearColor(le),n.setClearDepth(1)):n.fullSizeClearRect&&(l.clearColor&&n.setClearColor(h.camera.clearColor),l.clearDepth&&n.setClearDepth(h.camera.clearDepth),l.clearStencil&&n.setClearStencil(h.camera.clearStencil))),e.addRenderPass(n)}update(e){const t=this.scene.clusteredLightingEnabled;this.clustersDebugRendered=!1,this.initViewBindGroupFormat(),this.scene._updateSky(this.device);const s=this.updateLayerComposition(e,t),i=0!=(s&q);this.updateLightStats(e,s),this.beginFrame(e,i),this.setSceneConstants(),this.cullComposition(e),this.gpuUpdate(e._meshInstances)}renderPassDirectionalShadows(e,t){const s=t.layerList[e.layerIndex].cameras[e.cameraIndex];this.renderShadows(e.directionalLights,s.camera)}renderPassPostprocessing(e,t){t.layerList[e.layerIndex].cameras[e.cameraIndex].onPostprocessing()}renderPassRenderActions(e,t){const s=e._renderActions;for(let i=t.start;i<=t.end;i++)this.renderRenderAction(e,s[i],i===t.start)}renderRenderAction(e,t,s){const i=this.scene.clusteredLightingEnabled,a=this.device,r=t.layerIndex,o=e.layerList[r],n=e.subLayerList[r],l=t.cameraIndex,h=o.cameras[l];if(t.isLayerEnabled(e)){if(h&&t.firstCameraUse&&h.onPreRender&&h.onPreRender(),!n&&o.onPreRenderOpaque?o.onPreRenderOpaque(l):n&&o.onPreRenderTransparent&&o.onPreRenderTransparent(l),o._preRenderCalledForCameras&1<<l||(o.onPreRender&&o.onPreRender(l),o._preRenderCalledForCameras|=1<<l),h){var d;this.setupViewport(h.camera,t.renderTarget),s&&h.camera.fullSizeClearRect||this.clear(t,h.camera),o._sortVisible(n,h.camera.node,l);const e=o.instances,r=n?e.visibleTransparent[l]:e.visibleOpaque[l];this.scene.immediate.onPreRenderLayer(o,r,n),i&&t.lightClusters&&(t.lightClusters.activate(this.lightTextureAtlas),this.clustersDebugRendered||this.scene.lighting.debugLayer!==o.id||(this.clustersDebugRendered=!0)),this.scene._activeCamera=h.camera,this.setCameraUniforms(h.camera,t.renderTarget,t);const c=!!(h.camera._flipFaces^(null==t||null==(d=t.renderTarget)?void 0:d.flipY)),u=this._forwardDrawCalls;this.renderForward(h.camera,r.list,r.length,o._splitLights,o.shaderPass,o.cullingMask,o.onDrawCall,o,c),o._forwardDrawCalls+=this._forwardDrawCalls-u,a.setColorWrite(!0,!0,!0,!0),a.setStencilTest(!1),a.setAlphaToCoverage(!1),a.setDepthBias(!1),t.lastCameraUse&&h.onPostRender&&h.onPostRender()}!n&&o.onPostRenderOpaque?o.onPostRenderOpaque(l):n&&o.onPostRenderTransparent&&o.onPostRenderTransparent(l),!o.onPostRender||o._postRenderCalledForCameras&1<<l||(o._postRenderCounter&=~(n?2:1),0===o._postRenderCounter&&(o.onPostRender(l),o._postRenderCalledForCameras|=1<<l,o._postRenderCounter=o._postRenderCounterMax))}}}export{Ie as ForwardRenderer};

class e{constructor(){this.index=0,this.boneIndices=[0,0,0,0]}}class t{constructor(){this.partition=0,this.vertexStart=0,this.vertexCount=0,this.indexStart=0,this.indexCount=0,this.boneIndices=[],this.vertices=[],this.indices=[],this.indexMap={},this.originalMesh=null}addVertex(e,t,n){let s=-1;if(void 0!==this.indexMap[t])s=this.indexMap[t],this.indices.push(s);else{for(let s=0;s<4;s++){if(0===n.blendWeight.data[4*t+s])continue;const i=n.blendIndices.data[4*e.index+s];e.boneIndices[s]=this.getBoneRemap(i)}s=this.vertices.length,this.indices.push(s),this.vertices.push(e),this.indexMap[t]=s}}addPrimitive(e,t,n,s){const i=[];let o=0;const r=e.length;for(let t=0;t<r;t++){const s=e[t].index;for(let e=0;e<4;e++)if(n.blendWeight.data[4*s+e]>0){const t=n.blendIndices.data[4*s+e];let r=!0;for(let e=0;e<o;e++)if(i[e]===t){r=!1;break}if(r){i[o]=t;o+=-1===this.getBoneRemap(t)?1:0}}}if(this.boneIndices.length+o>s)return!1;for(let e=0;e<o;e++)this.boneIndices.push(i[e]);for(let s=0;s<r;s++)this.addVertex(e[s],t[s],n);return!0}getBoneRemap(e){for(let t=0;t<this.boneIndices.length;t++)if(this.boneIndices[t]===e)return t;return-1}}function n(n,s,i){let o,r,h,c;!function(e){const t=e.vertices,n=e.skins,s=e.meshes,i=e.meshInstances;for(let e=0;e<s.length;e++)s[e].vertices=t[s[e].vertices],void 0!==s[e].skin&&(s[e].skin=n[s[e].skin]);for(let e=0;e<i.length;e++)i[e].mesh=s[i[e].mesh]}(n);const l=n.vertices,a=n.skins;let d;const f=n.meshes,g=n.meshInstances,p=function(t){const n=new e;return n.index=t,n};for(o=a.length-1;o>=0;o--)if(a[o].boneNames.length>i){const e=a.splice(o,1)[0],n=[];for(r=0;r<f.length;r++)f[r].skin===e&&n.push(f[r]);for(r=0;r<n.length;r++)c=f.indexOf(n[r]),-1!==c&&f.splice(c,1);if(0===n.length)throw new Error("partitionSkin: There should be at least one mesh that references a skin");const u=n[0].vertices;for(r=1;r<n.length;r++)if(n[r].vertices!==u)throw new Error("partitionSkin: All meshes that share a skin should also share the same vertex buffer");let m;const v=[],x=[],b=[];let k=0;for(r=0;r<n.length;r++){d=n[r];const e=d.indices;for(let n=d.base;n<d.base+d.count;){c=e[n++],x[0]=p(c),b[0]=c,c=e[n++],x[1]=p(c),b[1]=c,c=e[n++],x[2]=p(c),b[2]=c;let s=!1;for(let e=k;e<v.length;e++)if(m=v[e],m.addPrimitive(x,b,u,i)){s=!0;break}s||(m=new t,m.originalMesh=d,m.addPrimitive(x,b,u,i),v.push(m))}k=v.length}const I=[],M=[];for(r=0;r<v.length;r++)if(m=v[r],m.vertices.length&&m.indices.length){const e=I.length,t=m.vertices.length,n=M.length,s=m.indices.length;let i,o;for(m.partition=r,m.vertexStart=e,m.vertexCount=t,m.indexStart=n,m.indexCount=s,i=0,o=e;i<t;)I[o++]=m.vertices[i++];for(i=0,o=n;i<s;)M[o++]=m.indices[i++]+e}const w=[];for(r=0;r<v.length;r++){m=v[r];const t=[],n=[];for(h=0;h<m.boneIndices.length;h++)t.push(e.inverseBindMatrices[m.boneIndices[h]]),n.push(e.boneNames[m.boneIndices[h]]);const s={inverseBindMatrices:t,boneNames:n};w.push(s),a.push(s)}let C,S,B,O;const y={};for(S in u)y[S]={components:u[S].components,data:[],type:u[S].type};for(S in u)if("blendIndices"===S){const e=y[S].data;for(r=0;r<I.length;r++){const t=I[r].boneIndices;e.push(t[0],t[1],t[2],t[3])}}else for(C=u[S],B=C.data,O=C.components,r=0;r<I.length;r++)for(c=I[r].index,h=0;h<O;h++)y[S].data.push(B[c*O+h]);for(l[l.indexOf(u)]=y,r=0;r<v.length;r++)for(m=v[r],d={aabb:{min:[0,0,0],max:[0,0,0]},vertices:y,skin:w[r],indices:M.splice(0,m.indexCount),type:"triangles",base:0,count:m.indexCount},f.push(d),h=g.length-1;h>=0;h--)g[h].mesh===m.originalMesh&&(g.push({mesh:d,node:g[h].node}),s&&s.push({material:s[h].material,path:s[h].path}));for(r=0;r<v.length;r++)for(m=v[r],h=g.length-1;h>=0;h--)g[h].mesh===m.originalMesh&&(g.splice(h,1),s&&s.splice(h,1))}!function(e){const t=e.vertices,n=e.skins,s=e.meshes,i=e.meshInstances;for(let e=0;e<s.length;e++)s[e].vertices=t.indexOf(s[e].vertices),void 0!==s[e].skin&&(s[e].skin=n.indexOf(s[e].skin));for(let e=0;e<i.length;e++)i[e].mesh=s.indexOf(i[e].mesh)}(n)}export{n as partitionSkin};

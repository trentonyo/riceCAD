import"./tracing.js";const e=/[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension)/g,n=/define[ \t]+([^\n]+)\r?(?:\n|$)/g,t=/extension[ \t]+([\w-]+)[ \t]*:[ \t]*enable/g,s=/undef[ \t]+([^\n]+)\r?(?:\n|$)/g,r=/(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g,l=/(endif|else|elif)([ \t]+[^\r\n]+)?\r?(?:\n|$)/g,i=/([\w-]+)/,a=/(!|\s)?defined\(([\w-]+)\)/,d=/[><=|&+-]/g;class c{static run(e){return e=(e=e.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm,"$1")).split(/\r?\n/).map((e=>e.trimEnd())).join("\n"),null!==(e=this._preprocess(e))&&(e=(e=e.split(/\r?\n/).map((e=>""===e.trim()?"":e)).join("\n")).replace(/(\n\n){3,}/gm,"\n\n")),e}static _preprocess(a){const d=a,x=[];let f=!1;const o=new Map;let p;for(;null!==(p=e.exec(a));){const d=p[1];switch(d){case"define":{n.lastIndex=p.index;const t=n.exec(a);f||(f=null===t);const s=t[1];i.lastIndex=t.index;const r=i.exec(s)[1];let l=s.substring(r.length).trim();""===l&&(l="true");c._keep(x)&&o.set(r,l),e.lastIndex=t.index+t[0].length;break}case"undef":{s.lastIndex=p.index;const n=s.exec(a),t=n[1].trim();c._keep(x)&&o.delete(t),e.lastIndex=n.index+n[0].length;break}case"extension":{t.lastIndex=p.index;const n=t.exec(a);if(f||(f=null===n),n){const e=n[1];c._keep(x)&&o.set(e,"true")}e.lastIndex=n.index+n[0].length;break}case"ifdef":case"ifndef":case"if":{r.lastIndex=p.index;const n=r.exec(a),t=n[2],s=c.evaluate(t,o);f||(f=s.error);let l=s.result;"ifndef"===d&&(l=!l),x.push({anyKeep:l,keep:l,start:p.index,end:r.lastIndex}),e.lastIndex=n.index+n[0].length;break}case"endif":case"else":case"elif":{l.lastIndex=p.index;const n=l.exec(a),t=x.pop(),s=t.keep?a.substring(t.end,p.index):"";a=a.substring(0,t.start)+s+a.substring(l.lastIndex),e.lastIndex=t.start+s.length;const r=n[1];if("else"===r||"elif"===r){let s=!1;if(!t.anyKeep)if("else"===r)s=!t.keep;else{const e=c.evaluate(n[2],o);s=e.result,f||(f=e.error)}x.push({anyKeep:t.anyKeep||s,keep:s,start:e.lastIndex,end:e.lastIndex})}break}}}return f?(console.warn("Failed to preprocess shader: ",{source:d}),d):a}static _keep(e){for(let n=0;n<e.length;n++)if(!e[n].keep)return!1;return!0}static evaluate(e,n){const t=null===d.exec(e);let s=!1;const r=a.exec(e);r&&(s="!"===r[1],e=r[2]),e=e.trim();let l=n.has(e);return s&&(l=!l),{result:l,error:!t}}}export{c as Preprocessor};

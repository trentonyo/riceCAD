function t(t){let h="";if((t.authority||t.scheme)&&(t.host||t.hostpath))throw new Error("Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option");if(t.host&&t.hostpath)throw new Error("Can't have 'host' and 'hostpath' option");if(t.path&&t.hostpath)throw new Error("Can't have 'path' and 'hostpath' option");return t.scheme&&(h+=t.scheme+":"),t.authority&&(h+="//"+t.authority),t.host&&(h+=t.host),t.path&&(h+=t.path),t.hostpath&&(h+=t.hostpath),t.query&&(h+="?"+t.query),t.fragment&&(h+="#"+t.fragment),h}const h=/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class o{constructor(t){const o=t.match(h);this.scheme=o[2],this.authority=o[4],this.path=o[5],this.query=o[7],this.fragment=o[9]}toString(){let t="";return this.scheme&&(t+=this.scheme+":"),this.authority&&(t+="//"+this.authority),t+=this.path,this.query&&(t+="?"+this.query),this.fragment&&(t+="#"+this.fragment),t}getQuery(){const t={};if(this.query){const h=decodeURIComponent(this.query).split("&");for(const o of h){const h=o.split("=");t[h[0]]=h[1]}}return t}setQuery(t){let h="";for(const o in t)t.hasOwnProperty(o)&&(""!==h&&(h+="&"),h+=encodeURIComponent(o)+"="+encodeURIComponent(t[o]));this.query=h}}export{o as URI,t as createURI};

import{extend as t}from"../core.js";import{CURVE_SMOOTHSTEP as e}from"./constants.js";import{CurveEvaluator as s}from"./curve-evaluator.js";class n{constructor(t){if(this.keys=[],this.type=e,this.tension=.5,this._eval=new s(this),t)for(let e=0;e<t.length-1;e+=2)this.keys.push([t[e],t[e+1]]);this.sort()}get length(){return this.keys.length}add(t,e){const s=this.keys,n=s.length;let r=0;for(;r<n&&!(s[r][0]>t);r++);const o=[t,e];return this.keys.splice(r,0,o),o}get(t){return this.keys[t]}sort(){this.keys.sort((function(t,e){return t[0]-e[0]}))}value(t){return this._eval.evaluate(t,!0)}closest(t){const e=this.keys,s=e.length;let n=2,r=null;for(let o=0;o<s;o++){const s=Math.abs(t-e[o][0]);if(!(n>=s))break;n=s,r=e[o]}return r}clone(){const e=new this.constructor;return e.keys=t(e.keys,this.keys),e.type=this.type,e.tension=this.tension,e}quantize(t){t=Math.max(t,2);const e=new Float32Array(t),s=1/(t-1);e[0]=this._eval.evaluate(0,!0);for(let n=1;n<t;n++)e[n]=this._eval.evaluate(s*n);return e}quantizeClamped(t,e,s){const n=this.quantize(t);for(let t=0;t<n.length;++t)n[t]=Math.min(s,Math.max(e,n[t]));return n}}export{n as Curve};

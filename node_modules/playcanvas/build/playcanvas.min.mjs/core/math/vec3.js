class t{constructor(t=0,s=0,h=0){3===t.length?(this.x=t[0],this.y=t[1],this.z=t[2]):(this.x=t,this.y=s,this.z=h)}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}add2(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}clone(){return new(0,this.constructor)(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}cross(t,s){const h=t.x,i=t.y,r=t.z,e=s.x,z=s.y,x=s.z;return this.x=i*x-z*r,this.y=r*e-x*h,this.z=h*z-e*i,this}distance(t){const s=this.x-t.x,h=this.y-t.y,i=this.z-t.z;return Math.sqrt(s*s+h*h+i*i)}div(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}div2(t,s){return this.x=t.x/s.x,this.y=t.y/s.y,this.z=t.z/s.z,this}divScalar(t){return this.x/=t,this.y/=t,this.z/=t,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}lerp(t,s,h){return this.x=t.x+h*(s.x-t.x),this.y=t.y+h*(s.y-t.y),this.z=t.z+h*(s.z-t.z),this}mul(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}mul2(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this.z=t.z*s.z,this}mulScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}normalize(){const t=this.x*this.x+this.y*this.y+this.z*this.z;if(t>0){const s=1/Math.sqrt(t);this.x*=s,this.y*=s,this.z*=s}return this}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}min(t){return t.x<this.x&&(this.x=t.x),t.y<this.y&&(this.y=t.y),t.z<this.z&&(this.z=t.z),this}max(t){return t.x>this.x&&(this.x=t.x),t.y>this.y&&(this.y=t.y),t.z>this.z&&(this.z=t.z),this}project(t){const s=(this.x*t.x+this.y*t.y+this.z*t.z)/(t.x*t.x+t.y*t.y+t.z*t.z);return this.x=t.x*s,this.y=t.y*s,this.z=t.z*s,this}set(t,s,h){return this.x=t,this.y=s,this.z=h,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}sub2(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}toString(){return`[${this.x}, ${this.y}, ${this.z}]`}}t.ZERO=Object.freeze(new t(0,0,0)),t.ONE=Object.freeze(new t(1,1,1)),t.UP=Object.freeze(new t(0,1,0)),t.DOWN=Object.freeze(new t(0,-1,0)),t.RIGHT=Object.freeze(new t(1,0,0)),t.LEFT=Object.freeze(new t(-1,0,0)),t.FORWARD=Object.freeze(new t(0,0,-1)),t.BACK=Object.freeze(new t(0,0,1));export{t as Vec3};

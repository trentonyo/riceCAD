import{CURVE_SMOOTHSTEP as t}from"./constants.js";import{Curve as e}from"./curve.js";import{CurveEvaluator as s}from"./curve-evaluator.js";class r{constructor(){if(this.curves=[],this._type=t,arguments.length>1)for(let t=0;t<arguments.length;t++)this.curves.push(new e(arguments[t]));else if(0===arguments.length)this.curves.push(new e);else{const t=arguments[0];if("number"==typeof t)for(let s=0;s<t;s++)this.curves.push(new e);else for(let s=0;s<t.length;s++)this.curves.push(new e(t[s]))}}get length(){return this.curves.length}set type(t){this._type=t;for(let e=0;e<this.curves.length;e++)this.curves[e].type=t}get type(){return this._type}get(t){return this.curves[t]}value(t,e=[]){const s=this.curves.length;e.length=s;for(let r=0;r<s;r++)e[r]=this.curves[r].value(t);return e}clone(){const t=new this.constructor;t.curves=[];for(let e=0;e<this.curves.length;e++)t.curves.push(this.curves[e].clone());return t._type=this._type,t}quantize(t){t=Math.max(t,2);const e=this.curves.length,r=new Float32Array(t*e),n=1/(t-1);for(let h=0;h<e;h++){const u=new s(this.curves[h]);for(let s=0;s<t;s++)r[s*e+h]=u.evaluate(n*s)}return r}quantizeClamped(t,e,s){const r=this.quantize(t);for(let t=0;t<r.length;++t)r[t]=Math.min(s,Math.max(e,r[t]));return r}}export{r as CurveSet};

class t{constructor(t=0,s=0){2===t.length?(this.x=t[0],this.y=t[1]):(this.x=t,this.y=s)}add(t){return this.x+=t.x,this.y+=t.y,this}add2(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this}addScalar(t){return this.x+=t,this.y+=t,this}clone(){return new(0,this.constructor)(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}cross(t){return this.x*t.y-this.y*t.x}distance(t){const s=this.x-t.x,h=this.y-t.y;return Math.sqrt(s*s+h*h)}div(t){return this.x/=t.x,this.y/=t.y,this}div2(t,s){return this.x=t.x/s.x,this.y=t.y/s.y,this}divScalar(t){return this.x/=t,this.y/=t,this}dot(t){return this.x*t.x+this.y*t.y}equals(t){return this.x===t.x&&this.y===t.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSq(){return this.x*this.x+this.y*this.y}lerp(t,s,h){return this.x=t.x+h*(s.x-t.x),this.y=t.y+h*(s.y-t.y),this}mul(t){return this.x*=t.x,this.y*=t.y,this}mul2(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this}mulScalar(t){return this.x*=t,this.y*=t,this}normalize(){const t=this.x*this.x+this.y*this.y;if(t>0){const s=1/Math.sqrt(t);this.x*=s,this.y*=s}return this}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}min(t){return t.x<this.x&&(this.x=t.x),t.y<this.y&&(this.y=t.y),this}max(t){return t.x>this.x&&(this.x=t.x),t.y>this.y&&(this.y=t.y),this}set(t,s){return this.x=t,this.y=s,this}sub(t){return this.x-=t.x,this.y-=t.y,this}sub2(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this}subScalar(t){return this.x-=t,this.y-=t,this}toString(){return`[${this.x}, ${this.y}]`}static angleRad(t,s){return Math.atan2(t.x*s.y-t.y*s.x,t.x*s.x+t.y*s.y)}}t.ZERO=Object.freeze(new t(0,0)),t.ONE=Object.freeze(new t(1,1)),t.UP=Object.freeze(new t(0,1)),t.DOWN=Object.freeze(new t(0,-1)),t.RIGHT=Object.freeze(new t(1,0)),t.LEFT=Object.freeze(new t(-1,0));export{t as Vec2};

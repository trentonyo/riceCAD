import"../tracing.js";import{Vec3 as t}from"../math/vec3.js";const s=new t,e=new t,a=new t,n=new t,h=new t;class i{constructor(s=new t,e=new t(.5,.5,.5)){this.center=s,this.halfExtents=e,this._min=new t,this._max=new t}add(t){const s=this.center,e=s.x,a=s.y,n=s.z,h=this.halfExtents,i=h.x,x=h.y,r=h.z;let M=e-i,c=e+i,y=a-x,o=a+x,z=n-r,l=n+r;const u=t.center,m=u.x,b=u.y,E=u.z,f=t.halfExtents,d=f.x,A=f.y,g=f.z,_=m-d,p=m+d,L=b-A,N=b+A,U=E-g,V=E+g;_<M&&(M=_),p>c&&(c=p),L<y&&(y=L),N>o&&(o=N),U<z&&(z=U),V>l&&(l=V),s.x=.5*(M+c),s.y=.5*(y+o),s.z=.5*(z+l),h.x=.5*(c-M),h.y=.5*(o-y),h.z=.5*(l-z)}copy(t){this.center.copy(t.center),this.halfExtents.copy(t.halfExtents)}clone(){return new i(this.center.clone(),this.halfExtents.clone())}intersects(t){const s=this.getMax(),e=this.getMin(),a=t.getMax(),n=t.getMin();return e.x<=a.x&&s.x>=n.x&&e.y<=a.y&&s.y>=n.y&&e.z<=a.z&&s.z>=n.z}_intersectsRay(t,h){const i=s.copy(this.getMin()).sub(t.origin),x=e.copy(this.getMax()).sub(t.origin),r=t.direction;0===r.x?(i.x=i.x<0?-Number.MAX_VALUE:Number.MAX_VALUE,x.x=x.x<0?-Number.MAX_VALUE:Number.MAX_VALUE):(i.x/=r.x,x.x/=r.x),0===r.y?(i.y=i.y<0?-Number.MAX_VALUE:Number.MAX_VALUE,x.y=x.y<0?-Number.MAX_VALUE:Number.MAX_VALUE):(i.y/=r.y,x.y/=r.y),0===r.z?(i.z=i.z<0?-Number.MAX_VALUE:Number.MAX_VALUE,x.z=x.z<0?-Number.MAX_VALUE:Number.MAX_VALUE):(i.z/=r.z,x.z/=r.z);const M=a.set(Math.min(i.x,x.x),Math.min(i.y,x.y),Math.min(i.z,x.z)),c=n.set(Math.max(i.x,x.x),Math.max(i.y,x.y),Math.max(i.z,x.z)),y=Math.min(Math.min(c.x,c.y),c.z),o=Math.max(Math.max(M.x,M.y),M.z),z=y>=o&&o>=0;return z&&h.copy(t.direction).mulScalar(o).add(t.origin),z}_fastIntersectsRay(t){const i=s,x=e,r=a,M=n,c=h,y=t.direction;return i.sub2(t.origin,this.center),M.set(Math.abs(i.x),Math.abs(i.y),Math.abs(i.z)),r.mul2(i,y),!(M.x>this.halfExtents.x&&r.x>=0)&&(!(M.y>this.halfExtents.y&&r.y>=0)&&(!(M.z>this.halfExtents.z&&r.z>=0)&&(c.set(Math.abs(y.x),Math.abs(y.y),Math.abs(y.z)),x.cross(y,i),x.set(Math.abs(x.x),Math.abs(x.y),Math.abs(x.z)),!(x.x>this.halfExtents.y*c.z+this.halfExtents.z*c.y)&&(!(x.y>this.halfExtents.x*c.z+this.halfExtents.z*c.x)&&!(x.z>this.halfExtents.x*c.y+this.halfExtents.y*c.x)))))}intersectsRay(t,s){return s?this._intersectsRay(t,s):this._fastIntersectsRay(t)}setMinMax(t,s){this.center.add2(s,t).mulScalar(.5),this.halfExtents.sub2(s,t).mulScalar(.5)}getMin(){return this._min.copy(this.center).sub(this.halfExtents)}getMax(){return this._max.copy(this.center).add(this.halfExtents)}containsPoint(t){const s=this.getMin(),e=this.getMax();return!(t.x<s.x||t.x>e.x||t.y<s.y||t.y>e.y||t.z<s.z||t.z>e.z)}setFromTransformedAabb(t,s,e=!1){const a=t.center,n=t.halfExtents,h=s.data;let i=h[0],x=h[4],r=h[8],M=h[1],c=h[5],y=h[9],o=h[2],z=h[6],l=h[10];if(e){let t=i*i+x*x+r*r;if(t>0){const s=1/Math.sqrt(t);i*=s,x*=s,r*=s}if(t=M*M+c*c+y*y,t>0){const s=1/Math.sqrt(t);M*=s,c*=s,y*=s}if(t=o*o+z*z+l*l,t>0){const s=1/Math.sqrt(t);o*=s,z*=s,l*=s}}this.center.set(h[12]+i*a.x+x*a.y+r*a.z,h[13]+M*a.x+c*a.y+y*a.z,h[14]+o*a.x+z*a.y+l*a.z),this.halfExtents.set(Math.abs(i)*n.x+Math.abs(x)*n.y+Math.abs(r)*n.z,Math.abs(M)*n.x+Math.abs(c)*n.y+Math.abs(y)*n.z,Math.abs(o)*n.x+Math.abs(z)*n.y+Math.abs(l)*n.z)}static computeMinMax(t,s,e,a=t.length/3){if(a>0){s.set(t[0],t[1],t[2]),e.set(t[0],t[1],t[2]);for(let n=1;n<a;n++){const a=t[3*n+0],h=t[3*n+1],i=t[3*n+2];a<s.x&&(s.x=a),h<s.y&&(s.y=h),i<s.z&&(s.z=i),a>e.x&&(e.x=a),h>e.y&&(e.y=h),i>e.z&&(e.z=i)}}}compute(t,a){i.computeMinMax(t,s,e,a),this.setMinMax(s,e)}intersectsBoundingSphere(t){return this._distanceToBoundingSphereSq(t)<=t.radius*t.radius}_distanceToBoundingSphereSq(t){const s=this.getMin(),e=this.getMax();let a=0;const n=["x","y","z"];for(let h=0;h<3;++h){let i=0;const x=t.center[n[h]],r=s[n[h]],M=e[n[h]];let c=0;x<r&&(c=r-x,i+=c*c),x>M&&(c=x-M,i+=c*c),a+=i}return a}_expand(t,a){s.add2(this.getMin(),t),e.add2(this.getMax(),a),this.setMinMax(s,e)}}export{i as BoundingBox};

<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>riceCAD</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="../playcanvas-latest.js"></script>
        <script src="../FileSaver.js"></script>
    </head>
    <body>
        <script src="materials.js"></script>
        <table>
            <tr>
                <td id="editor_title" colspan="3">riceCAD v0.0.0</td>
            </tr>
            <tr>
                <td id="editor_lpanel">Left panel</td>
                <td id="editor">        
                    <canvas id="application-canvas" width="800" height="600"></canvas>
                </td>
                <td id="editor_rpanel">Right panel<br>
                    <textarea id="editor_text" wrap="off" onchange="loadFromTextArea()">1</textarea>
                    <button onclick="downloadChanges()">Download Changes</button>
                </td>
            </tr>
            <tr>
                <td id="edit_bpanel" colspan="3">Bottom panel
                <input type="file" id="file-selector" accept=".plan">
                </td>
            </tr>
        </table>
        
        <script>
            const fileSelector = document.getElementById('file-selector');
            fileSelector.addEventListener('change', (event) => 
            {
                const fileList = event.target.files;
                console.log(fileList);
                
                const content = document.getElementById('editor_text');
                const [file] = fileList;
                const reader = new FileReader();

                reader.addEventListener("load", () => 
                {
                    // this will then display a text file
                    content.value = reader.result.replace(/\r/g, "\n");
                    loadFromTextArea();
                    
                }, false);

                if (file) {
                  reader.readAsText(file);
                }
                
            });
            
            function downloadChanges()
            {
                const content = document.getElementById('editor_text');

                var file = new File([content.value], "riceCAD.plan", {type: "text/plain;charset=utf-8"});
                saveAs(file);
            }
            
            var canvas = document.getElementById("application-canvas");
            var app = new pc.Application(canvas);
            app.start();
            
            app.setCanvasFillMode(pc.FILLMODE_NONE);
            app.setCanvasResolution(pc.RESOLUTION_AUTO);

            var camera = new pc.Entity();
            camera.addComponent("camera", {
                clearColor: new pc.Color(0.0, 1.0, 1.0)
            });

            app.root.addChild(camera);

            var camerasRX = [-0.26, 0.06,-0.12,-0.77,-0.26];
            var camerasRY = [ 0.37, 0.92,-0.7 , 0.0 , 0.0 ];
            var camerasRZ = [ 0.10, 0.17,-0.12, 0.0 , 0.0 ];
            var camerasRW = [ 0.88,-0.35, 0.7 , 0.63, 0.97];
            
            var camerasPX = [ 45.0,-13.0,-23.0, 9.0 , 0.0 ];
            var camerasPY = [ 32.0, 14.0, 17.0,35.0 ,10.0 ];
            var camerasPZ = [ 45.0,-13.0, 12.0,-2.0 ,10.0 ];

            function setCamera(cam)
            {
                camera.setRotation( camerasRX[cam], 
                                    camerasRY[cam], 
                                    camerasRZ[cam], 
                                    camerasRW[cam], 
                                    );
                                    
                camera.setPosition( camerasPX[cam], 
                                    camerasPY[cam], 
                                    camerasPZ[cam]);
            }

            //setCamera(0);
            setCamera(0);
            console.log(camera.rotation);

            //                 ri     away
            app.scene.ambientLight = new pc.Color(0.5, 0.5, 0.5);
            var light = new pc.Entity();
            light.addComponent('light');
            app.root.addChild(light);
            light.rotate(45, 0, 0);
            
            var workingPlane = new pc.Entity();
            workingPlane.addComponent("model", { type: "plane" });
            workingPlane.rotate(0, 0, 0);
            workingPlane.setPosition(5, 0, 5);
            workingPlane.setLocalScale(10, 0, 10);
            app.root.addChild(workingPlane);

            function updateWorkingPlane(width, depth)
            {
                var margin = 1;
                workingPlane.setPosition((width + margin) / 2, 0, (depth + margin) / 2);
                workingPlane.setLocalScale((width + margin), 0, (depth + margin));
            }

            //Camera and scene initialized
    
            //Returns a matrix of the given size, initialized to 0
            function generateMatrix(width, height, depth)
            {
                var output = [];

                for (var i = 0; i < depth; i++)
                {
                    output.push([]);
                    for (var j = 0; j < height; j++)
                    {
                        output[i].push([]);
                        for (var k = 0; k < width; k++)
                        {
                            output[i][j].push(0);
                        }
                    }
                }

                return output;
            }

            //Copies all values from first into second
            function transferMatrices(first, fWidth, fHeight, fDepth, second)
            {
                for (var i = 0; i < fWidth; i++)
                {
                    for (var j = 0; j < fHeight; j++)
                    {
                        for (var k = 0; k < fDepth; k++)
                        {
                            //console.log("setting [" + second[i][j][k] + "] at " + i + ", " +  j + ", " +  k + ", " + 
                            //        "to [" + first[i][j][k] + "] at " + i + ", " +  j + ", " +  k + ", ");
                            second[i][j][k] = first[i][j][k];
                        }
                    }
                }
            }

            function resize(fwidth, fheight, fdepth)
            {
                console.log("Matrix BEFORE reassignment:");
                console.log(matrix);

                matrixBuffer = generateMatrix(width, height, depth);
                transferMatrices(matrix, fwidth, fheight, fdepth, matrixBuffer);

                matrix = generateMatrix(width, height, depth);
                console.log("Matrix has been reassigned:");
                console.log(matrix);
                matrix = Array.from(matrixBuffer);

                updateWorkingPlane(width, depth);
            }
            
            function clearMatrix(matrix)
            {
                for(var x = 0; x < depth; x++)
                {
                    for(var y = 0; y < height; y++)
                    {
                        for(var z = 0; z < width; z++)
                        {
                            matrix[x][y][z] = 0;
                        }
                    }
                }
            }
            //Initialize matrix
            let width = 64;
            let height = 100; 
            let depth = 64; 

            let matrix = generateMatrix(width, height, depth);
            let matrixBuffer = generateMatrix(width, height, depth);
            
            function loadFromTextArea()
            {
                /*matrix = generateMatrix(width, height, depth);
                //clearMatrix(matrix);
                */
               
                for(var x = 0; x < depth; x++)
                {
                    for(var y = 0; y < height; y++)
                    {
                        for(var z = 0; z < width; z++)
                        {
                            
                            if(typeof(matrix[z][y][x]) !== "number")
                            {
                                if(matrix[z][y][x].b !== 0)
                                {
                                    console.log("Found a block, destroying it");
                                    matrix[z][y][x].e.destroy();
                                }
                            }
                        }
                    }
                }
                
                const content = document.getElementById('editor_text');
                
                var lx = 0; //Width
                var ly = 0; //Height
                var lz = 0; //Depth
                
                var layers = [];
                layers = content.value.split("#");
                
                for(const layer of layers)
                {
                    var rows = [];
                    rows = layer.split("\n");
                    
                    for(const row of rows)
                    {
                        if(row !== "") //Checking for excess whitespace
                        {
                            var blocks = [];
                            blocks = row.split("");
                            
                            for(const block of blocks)
                            {
                                if(block !== "") //Checking for excess whitespace
                                {
                                    //console.log(block + ", ");
                                    
                                    addBlock(lx, ly, lz, parseInt(block));
                                    
                                    lx++;
                                }
                            }
                        
                            //console.log("/row");
                            lx = 0;
                            lz++;
                        }
                        
                    }
                    //console.log("/layer");
                    lx = 0;
                    ly++;
                    lz = 0;
                }
                
            }

            
            updateWorkingPlane(width, depth);

            class Block 
            {
                constructor(x, y, z, b)
                {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.b = b;
                    
                    if(b > 0)
                    {
                        var e = new pc.Entity();
                        e.addComponent("model", { type: "box", isStatic: true });
                        
                        switch (b) {
                            case blackCode:
                                e.model.model.meshInstances[0].material = blackMaterial;
                                break;
                            case redCode:
                                e.model.model.meshInstances[0].material = redMaterial;
                                break;
                            case greenCode:
                                e.model.model.meshInstances[0].material = greenMaterial;
                                break;
                            case brownCode:
                                e.model.model.meshInstances[0].material = brownMaterial;
                                break;
                            case blueCode:
                                e.model.model.meshInstances[0].material = blueMaterial;
                                break;
                            case purpleCode:
                                e.model.model.meshInstances[0].material = purpleMaterial;
                                break;
                            case cyanCode:
                                e.model.model.meshInstances[0].material = cyanMaterial;
                                break;
                            case lightGrayCode:
                                e.model.model.meshInstances[0].material = lightGrayMaterial;
                                break;
                            case grayCode:
                                e.model.model.meshInstances[0].material = grayMaterial;
                                break;
                            case pinkCode:
                                e.model.model.meshInstances[0].material = pinkMaterial;
                                break;
                            case limeCode:
                                e.model.model.meshInstances[0].material = limeMaterial;
                                break;
                            case yellowCode:
                                e.model.model.meshInstances[0].material = yellowMaterial;
                                break;
                            case lightBlueCode:
                                e.model.model.meshInstances[0].material = lightBlueMaterial;
                                break;
                            case magentaCode:
                                e.model.model.meshInstances[0].material = magentaMaterial;
                                break;
                            case orangeCode:
                                e.model.model.meshInstances[0].material = orangeMaterial;
                                break;
                            case whiteCode:
                                e.model.model.meshInstances[0].material = whiteMaterial;
                                break;
                            default:
                                e.model.model.meshInstances[0].material = whiteMaterial;
                        }

                        app.root.addChild(e);
                        e.setPosition(x + 0.5, y + 0.5, z + 0.5);

                        this.e = e;
                    }
                }
            }

            function addBlock(x, y, z, b)
            {   
                var toAdd = new Block(x, y, z, b);

                var resize = false;
                var fwidth = width;
                var fheight = height;
                var fdepth = depth;
                if(x > width)
                {
                    resize = true;
                    //width = x;
                }
                if(y > height)
                {
                    resize = true;
                    //height = y;
                }
                if(z > depth)
                {
                    resize = true;
                    //depth = z;
                }

                if (resize) 
                {    
                    //resize(fwidth, fheight, fdepth);
                    console.log("Resizing is still broken. Sorry.");
                }
                else
                {
                    if(typeof(matrix[z][y][x]) !== "number")
                    {
                        if(matrix[z][y][x].b !== 0)
                        {
                            console.log("Found a block, destroying it");
                            matrix[z][y][x].e.destroy();
                        }
                    }

                    matrix[z][y][x] = toAdd;   
                }
            }
    
            loadFromTextArea();
            
            for (var z = 0; z < matrix.length; z++)
            {
                for (var y = 0; y < matrix[z].length; y++)
                {
                    for (var x = 0; x < matrix[z][y].length; x++)
                    {
                        //Check if there is a block in the first place
                        if (matrix[z][y][x] === 0)
                        {
                            //There is NOT A block here
                        }
                        else
                        {
                            //There is a block here
                        }
                    }
                }
            }

            const mouse = new pc.Mouse(document.body);
            mouse.disableContextMenu();

            const keyboard = new pc.Keyboard(document.body);

            var x = 0;
            var y = 0;

            var rotateSpeed = 0.1;
            var moveSpeed = 0.05;
            var zoomModifier = 5;

            mouse.on("mousemove", function (event) {
                if (event.buttons[pc.MOUSEBUTTON_LEFT])
                {
                    x += event.dx;
                    y += event.dy;

                    camera.setLocalEulerAngles(rotateSpeed * y, rotateSpeed * x, 0);
                }
            });
            mouse.on("mousewheel", function (event) {

                camera.translateLocal(0, 0, moveSpeed * event.wheelDelta * zoomModifier);
                
            });
            
            var onKeyDown = function (e) 
            {   

                var digit = e.key - pc.KEY_0;
                if(0 <= digit && digit < 10)
                { 
                    if (keyboard.isPressed(pc.KEY_SHIFT)) 
                    {
                        //Set a camera angle
                        console.log("Setting camera angle " + digit + " to:");
                        
                        var rX = camera.rotation.x;
                        var rY = camera.rotation.y;
                        var rZ = camera.rotation.z;
                        var rW = camera.rotation.w;
                        
                        console.log([rX, rY, rZ, rW]);
                        
                        var pX = camera.position.x;
                        var pY = camera.position.y;
                        var pZ = camera.position.z;
                        
                        console.log([pX, pY, pZ]);
                        
                        camerasRX[digit] = camera.rotation.x;
                        camerasRY[digit] = camera.rotation.y;
                        camerasRZ[digit] = camera.rotation.z;
                        camerasRW[digit] = camera.rotation.w;
                        
                        camerasPX[digit] = camera.position.x;
                        camerasPY[digit] = camera.position.y;
                        camerasPZ[digit] = camera.position.z;
                        
                    }
                    else
                    {   
                        //Pick a camera angle
                        setCamera(digit);
                    }
                }
                
                
                //e.event.preventDefault(); // Use original browser event to prevent browser action.
            };
            keyboard.on("keydown", onKeyDown, this);

            app.on("update", function () {
                if (keyboard.isPressed(pc.KEY_SHIFT))   //Shift held
                {
                    //Move camera up/down global
                    if (keyboard.isPressed(pc.KEY_W)) {
                        camera.translate(0, moveSpeed, 0);
                    }
                    if (keyboard.isPressed(pc.KEY_S)) {
                        camera.translate(0, -moveSpeed, 0);
                    }
                }
                else                                    //Shift up
                {
                    //Move camera up/down local
                    if (keyboard.isPressed(pc.KEY_W)) {
                        camera.translateLocal(0, 0, -moveSpeed);
                    }
                    if (keyboard.isPressed(pc.KEY_S)) {
                        camera.translateLocal(0, 0, moveSpeed);
                    }
                }
                if (keyboard.isPressed(pc.KEY_UP)) {
                    camera.rotate(rotateSpeed, 0, 0);
                }
                if (keyboard.isPressed(pc.KEY_DOWN)) {
                    camera.rotate(-rotateSpeed, 0, 0);
                }
                if (keyboard.isPressed(pc.KEY_LEFT)) {
                    camera.rotate(0, rotateSpeed, 0);
                }
                if (keyboard.isPressed(pc.KEY_RIGHT)) {
                    camera.rotate(0, -rotateSpeed, 0);
                }
                if (keyboard.isPressed(pc.KEY_A)) {
                    camera.translateLocal(-moveSpeed, 0, 0);
                }
                if (keyboard.isPressed(pc.KEY_D)) {
                    camera.translateLocal(moveSpeed, 0, 0);
                }
            });


            /* Used playcanvas example update function
            let time = 0;
            let step = 0;
            
            app.on("update", function (dt) 
            {
                time += dt; 
                step += 1;
                
                if(dt >= 0.25)
                {
                    time = 0;
                }
                
                /* Show active bodies in red and frozen bodies in gray
                app.root.findComponents("rigidbody").forEach(function (body) 
                {
                    body.entity.findComponents("render").forEach(function (render) {
                        render.material = body.isActive() ? red : gray;
                    });
                }); /
            });*/

        </script>
    </body>
</html>
